% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_stackedbar.R
\name{create_stackedbar}
\alias{create_stackedbar}
\title{Create a Stacked Bar Chart}
\usage{
create_stackedbar(
  data,
  x_var,
  y_var = NULL,
  stack_var,
  title = NULL,
  subtitle = NULL,
  x_label = NULL,
  y_label = NULL,
  stack_label = NULL,
  stacked_type = c("counts", "percent"),
  tooltip_prefix = "",
  tooltip_suffix = "",
  x_tooltip_suffix = "",
  color_palette = NULL,
  stack_order = NULL,
  x_order = NULL,
  include_na = FALSE,
  na_label_x = "(Missing)",
  na_label_stack = "(Missing)",
  x_breaks = NULL,
  x_bin_labels = NULL,
  x_map_values = NULL,
  stack_breaks = NULL,
  stack_bin_labels = NULL,
  stack_map_values = NULL,
  horizontal = FALSE,
  weight_var = NULL
)
}
\arguments{
\item{data}{A data frame containing the raw survey data (e.g., one row per respondent).}

\item{x_var}{The name of the column to be plotted on the X-axis (as a string).
This typically represents a demographic variable or a question.}

\item{y_var}{Optional. The name of the column that already contains the counts
or values for the y-axis (as a string). If \code{NULL} (default),
the function will internally count the occurrences of \code{x_var} and \code{stack_var}.
Only provide this if your \code{data} is already aggregated.}

\item{stack_var}{The name of the column whose unique values will define the
stacks within each bar (as a string). This is often a
Likert scale, an agreement level, or another categorical response.}

\item{title}{Optional. The main title of the chart (as a string).}

\item{subtitle}{Optional. A subtitle for the chart (as a string).}

\item{x_label}{Optional. The label for the X-axis (as a string). Defaults
to \code{x_var} or \code{x_var (Binned)}.}

\item{y_label}{Optional. The label for the Y-axis (as a string). Defaults
to "Number of Respondents" or "Percentage of Respondents".}

\item{stack_label}{Optional. The title for the stack legend (as a string).
Set to NULL, NA, FALSE, or "" to hide the legend title completely.
If not provided, no title is shown.}

\item{stacked_type}{Optional. The type of stacking. Can be "counts" (counts)
or "percent" (100\% stacked). Defaults to "counts".}

\item{tooltip_prefix}{Optional. A string to prepend to values in tooltips.}

\item{tooltip_suffix}{Optional. A string to append to values in tooltips.}

\item{x_tooltip_suffix}{Optional. A string to append to x-axis values in tooltips.}

\item{color_palette}{Optional. A character vector of colors to use for the
stacks. If NULL, highcharter's default palette is used.
Consider ordering colors to match \code{stack_order}.}

\item{stack_order}{Optional. A character vector specifying the desired order
of the \code{stack_var} levels. This is crucial for ordinal
scales (e.g., Likert 1-7). If NULL, default factor order
or alphabetical will be used. Levels not found in data
will be ignored.}

\item{x_order}{Optional. A character vector specifying the desired order
of the \code{x_var} levels. If NULL, default factor order
or alphabetical will be used.}

\item{include_na}{Logical. If TRUE, explicit NA categories will be shown
in counts for \code{x_var} and \code{stack_var}. If FALSE (default),
rows with NA in \code{x_var} or \code{stack_var} are dropped.}

\item{na_label_x}{Optional string. Custom label for NA values in x_var. Defaults to "(Missing)".}

\item{na_label_stack}{Optional string. Custom label for NA values in stack_var. Defaults to "(Missing)".}

\item{x_breaks}{Optional. A numeric vector of cut points for \code{x_var} if
it is a continuous variable and you want to bin it.
e.g., \code{c(16, 24, 33, 42, 51, 60, Inf)}.}

\item{x_bin_labels}{Optional. A character vector of labels for the bins
created by \code{x_breaks}. Must be one less than the number
of breaks (or same if Inf is last break).}

\item{x_map_values}{Optional. A named list (e.g., \code{list("1" = "Female", "2" = "Male")})
to rename values within \code{x_var} for display. Original values
should be names, new labels should be values.}

\item{stack_breaks}{Optional. A numeric vector of cut points for \code{stack_var} if
it is a continuous variable and you want to bin it.}

\item{stack_bin_labels}{Optional. A character vector of labels for the bins
created by \code{stack_breaks}. Must be one less than the number
of breaks (or same if Inf is last break).}

\item{stack_map_values}{Optional. A named list (e.g., \code{list("1" = "Strongly Disagree", "7" = "Strongly Agree")})
to rename values within \code{stack_var} for display.}

\item{horizontal}{Logical. If \code{TRUE}, creates a horizontal bar chart (bars extend from left to right).
If \code{FALSE} (default), creates a vertical column chart (bars extend from bottom to top).
Note: When horizontal = TRUE, the stack order is automatically reversed so that
the visual order of the stacks matches the legend order.}
}
\value{
An interactive \code{highcharter} bar chart plot object.
}
\description{
This function creates a stacked barchart for survey data. It
handles raw (unaggregated) data, counting the occurrences of
categories, supporting ordered factors, allowing numerical x-axis
and stacked variables to be binned into custom groups, and
enables renaming of categorical values for display. It can also
handle SPSS (.sav) columns automatically.
}
\details{
This function performs the following steps:
\enumerate{
\item \strong{Input Validation:} Checks if the provided \code{data} is a data frame and if \code{x_var} and \code{stack_var} columns exist.
\item \strong{Data Copy:} Creates a mutable copy of the input \code{data} to perform transformations without affecting the original.
\item \strong{Handle 'haven_labelled' Columns:} If \code{haven} package is available, it detects if \code{x_var} or \code{stack_var} are of class \code{haven_labelled} (common for data imported from SPSS/Stata/SAS). If so, it converts them to standard R factors, using their underlying numeric values as levels (e.g., a '1' that was labeled "Male" will become a factor level "1"). This ensures \code{recode} can operate correctly.
\item \strong{Apply Value Mapping (\code{x_map_values}, \code{stack_map_values}):} If provided, \code{x_map_values} and \code{stack_map_values} (named lists, e.g., \code{list("1"="Male")}) are used to rename the values in \code{x_var} and \code{stack_var} respectively. This is useful for converting numeric codes or abbreviations into descriptive labels. If the column is a factor, it's temporarily converted to character to ensure \code{dplyr::recode} works reliably on the values.
\item \strong{Handle Binning (\code{x_breaks}, \code{x_bin_labels}, \code{stack_breaks}, \code{stack_bin_labels}):}
\itemize{
\item If \code{x_var} (or \code{stack_var}) is numeric and corresponding \verb{_breaks} are provided, the function uses \code{base::cut()} to discretize the numeric variable into bins.
\item \verb{_bin_labels} can be supplied to give custom names to these bins (e.g., "18-24" instead of "(17,25]"). If not provided, \code{cut()} generates default labels.
\item A temporary column (e.g., \code{.x_var_binned}) is created to hold the binned values, and this temporary column is then used for plotting.
}
\item \strong{Data Aggregation and Final Factor Handling:}
\itemize{
\item The data is transformed using \code{dplyr::mutate} to ensure \code{x_var} and \code{stack_var} (or their binned versions) are treated as factors. If \code{include_na = TRUE}, missing values are converted into an explicit "(NA)" factor level.
\item \code{dplyr::count()} is then used to aggregate the data, counting occurrences for each unique combination of \code{x_var} and \code{stack_var}. This creates the \code{n} column required for \code{highcharter}.
}
\item \strong{Apply Custom Ordering (\code{x_order}, \code{stack_order}):} If provided, \code{x_order} and \code{stack_order} are used to set the display order of the factor levels for the X-axis and stack categories, respectively. This is essential for ordinal scales (e.g., Likert scales) or custom desired sorting. Levels not found in the order vector are appended at the end.
\item \strong{Highcharter Chart Generation:} The aggregated \code{plot_data} is passed to \code{highcharter::hchart()} to create the base stacked column chart.
\item \strong{Chart Customization:} Titles, subtitles, axis labels, stacking type (counts vs. percent), data labels, legend titles, tooltips, and custom color palettes are applied based on the function's arguments.
\item \strong{Return Value:} The function returns a \code{highcharter} plot object, which can be printed directly to display the interactive chart.
}
}
\examples{
# We will be using data from GSS for these examples.
# Make sure you have the data loaded:
data(gss_all)

# Filter to recent years and select relevant variables
gss_recent <- gss_all \%>\%
  filter(year >= 2010) \%>\%
  select(age, degree, happy, sex, race, year, polviews, attend)

# Example 1: Basic stacked bar - Education by Gender
education_order <- c("Lt High School", "High School", "Junior College", "Bachelor", "Graduate")

plot1 <- create_stackedbar(
  data = gss_recent,
  x_var = "degree",
  stack_var = "sex",
  title = "Educational Attainment by Gender",
  subtitle = "GSS respondents 2010-present",
  x_label = "Highest Degree Completed",
  y_label = "Number of Respondents",
  stack_label = "Gender",
  x_order = education_order,
)
plot1

# Example 2: Percentage stacked - Happiness by Education Level
plot2 <- create_stackedbar(
  data = gss_recent,
  x_var = "degree",
  stack_var = "happy",
  title = "Happiness Distribution Across Education Levels",
  subtitle = "Percentage breakdown within each education category",
  x_label = "Education Level",
  y_label = "Percentage of Respondents",
  stack_label = "Happiness Level",
  stacked_type = "percent",
  x_order = education_order,
  stack_order = c("Very Happy", "Pretty Happy", "Not Too Happy"),
  tooltip_suffix = "\%",
  color_palette = c("turquoise", "slateblue", "steelblue")
)
plot2

# Example 3: Age binning with political views
age_breaks <- c(18, 30, 45, 60, 75, Inf)
age_labels <- c("18-29", "30-44", "45-59", "60-74", "75+")

# Map political views to shorter labels
polviews_map <- list(
  "Extremely Liberal" = "Ext Liberal",
  "Liberal" = "Liberal",
  "Slightly Liberal" = "Sl Liberal",
  "Moderate" = "Moderate",
  "Slightly Conservative" = "Sl Conservative",
  "Conservative" = "Conservative",
  "Extremely Conservative" = "Ext Conservative"
)

plot3 <- create_stackedbar(
  data = gss_recent,
  x_var = "age",
  stack_var = "polviews",
  title = "Political Views by Age Group",
  subtitle = "Distribution of political ideology across age cohorts",
  x_label = "Age Group",
  stack_label = "Political Views",
  x_breaks = age_breaks,
  x_bin_labels = age_labels,
  stack_map_values = polviews_map,
  stacked_type = "percent",
  tooltip_suffix = "\%",
  x_tooltip_suffix = " years",
)
plot3

# Example 4: Including NA values with custom labels
plot4 <- create_stackedbar(
  data = gss_recent,
  x_var = "race",
  stack_var = "attend",
  title = "Religious Attendance by Race/Ethnicity",
  subtitle = "Including non-responses as explicit category",
  x_label = "Race/Ethnicity",
  stack_label = "Religious Attendance",
  include_na = TRUE,
  na_label_x = "Not Specified",
  na_label_stack = "No Answer",
  stacked_type = "percent",
  tooltip_suffix = "\%"
)
plot4

# Example 5: Using pre-aggregated data
# Create aggregated data first
education_gender_counts <- gss_recent \%>\%
  filter(!is.na(degree) & !is.na(sex)) \%>\%
  count(degree, sex, name = "respondent_count") \%>\%
  mutate(degree = factor(degree, levels = education_order))

plot5 <- create_stackedbar(
  data = education_gender_counts,
  x_var = "degree",
  y_var = "respondent_count",  # Use pre-computed counts
  stack_var = "sex",
  title = "Education by Gender (Pre-aggregated Data)",
  subtitle = "Using pre-computed counts",
  x_label = "Education Level",
  y_label = "Number of Respondents",
  stack_label = "Gender",
)
plot5

# Example 6: Complex mapping with custom ordering
# Map sex to more descriptive labels
sex_map <- list("Male" = "Men", "Female" = "Women")

plot6 <- create_stackedbar(
  data = gss_recent,
  x_var = "happy",
  stack_var = "sex",
  title = "Gender Distribution Across Happiness Levels",
  subtitle = "With custom gender labels and happiness ordering",
  x_label = "Self-Reported Happiness",
  stack_label = "Gender",
  x_order = c("Very Happy", "Pretty Happy", "Not Too Happy"),
  stack_map_values = sex_map,
  stack_order = c("Women", "Men"),
  stacked_type = "counts",
  tooltip_prefix = "Count: ",
)
plot6


}
