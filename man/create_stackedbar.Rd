% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/viz.R
\name{create_stackedbar}
\alias{create_stackedbar}
\title{Create a Stacked Bar Chart}
\usage{
create_stackedbar(
  data,
  x_var,
  y_var = NULL,
  stack_var,
  title = NULL,
  subtitle = NULL,
  x_label = NULL,
  y_label = NULL,
  stack_label = NULL,
  stacked_type = c("normal", "percent"),
  tooltip_prefix = "",
  tooltip_suffix = "",
  color_palette = NULL,
  stack_order = NULL,
  x_order = NULL,
  include_na = FALSE,
  x_breaks = NULL,
  x_bin_labels = NULL,
  x_map_values = NULL,
  stack_breaks = NULL,
  stack_bin_labels = NULL,
  stack_map_values = NULL
)
}
\arguments{
\item{data}{A data frame containing the raw survey data (e.g., one row per respondent).}

\item{x_var}{The name of the column to be plotted on the X-axis (as a string).
This typically represents a demographic variable or a question.}

\item{stack_var}{The name of the column whose unique values will define the
stacks within each bar (as a string). This is often a
Likert scale, an agreement level, or another categorical response.}

\item{title}{Optional. The main title of the chart (as a string).}

\item{subtitle}{Optional. A subtitle for the chart (as a string).}

\item{x_label}{Optional. The label for the X-axis (as a string). Defaults
to \code{x_var} or \code{x_var (Binned)}.}

\item{y_label}{Optional. The label for the Y-axis (as a string). Defaults
to "Number of Respondents" or "Percentage of Respondents".}

\item{stack_label}{Optional. The title for the stack legend (as a string).
Defaults to \code{stack_var} or \code{stack_var (Binned)}.}

\item{stacked_type}{Optional. The type of stacking. Can be "normal" (counts)
or "percent" (100\% stacked). Defaults to "normal".}

\item{tooltip_prefix}{Optional. A string to prepend to values in tooltips.}

\item{tooltip_suffix}{Optional. A string to append to values in tooltips.}

\item{color_palette}{Optional. A character vector of colors to use for the
stacks. If NULL, highcharter's default palette is used.
Consider ordering colors to match \code{stack_order}.}

\item{stack_order}{Optional. A character vector specifying the desired order
of the \code{stack_var} levels. This is crucial for ordinal
scales (e.g., Likert 1-7). If NULL, default factor order
or alphabetical will be used. Levels not found in data
will be ignored.}

\item{x_order}{Optional. A character vector specifying the desired order
of the \code{x_var} levels. If NULL, default factor order
or alphabetical will be used.}

\item{include_na}{Logical. If TRUE, explicit "(NA)" categories will be shown
in counts for \code{x_var} and \code{stack_var}. If FALSE (default),
rows with NA in \code{x_var} or \code{stack_var} are dropped.}

\item{x_breaks}{Optional. A numeric vector of cut points for \code{x_var} if
it is a continuous variable and you want to bin it.
e.g., \code{c(16, 24, 33, 42, 51, 60, Inf)}.}

\item{x_bin_labels}{Optional. A character vector of labels for the bins
created by \code{x_breaks}. Must be one less than the number
of breaks (or same if Inf is last break).}

\item{x_map_values}{Optional. A named list (e.g., \code{list("1" = "Female", "2" = "Male")})
to rename values within \code{x_var} for display. Original values
should be names, new labels should be values.}

\item{stack_breaks}{Optional. A numeric vector of cut points for \code{stack_var} if
it is a continuous variable and you want to bin it.}

\item{stack_bin_labels}{Optional. A character vector of labels for the bins
created by \code{stack_breaks}. Must be one less than the number
of breaks (or same if Inf is last break).}

\item{stack_map_values}{Optional. A named list (e.g., \code{list("1" = "Strongly Disagree", "7" = "Strongly Agree")})
to rename values within \code{stack_var} for display.}
}
\value{
An interactive \code{highcharter} bar chart plot object.

#' @examplesEnsure necessary packages are installed and loaded for examplesinstall.packages(c("highcharter", "dplyr", "rlang", "tibble", "haven"))

library(highcharter)
library(dplyr)
library(rlang)
library(tibble) # For tibble::tibble() and tibble::as_tibble()library(haven) # Only needed if your real data is 'haven_labelled' typeUsing the provided dummy data R file

dummy1 <- create_stackedbar(
data = survey_data,
x_var = "satisfaction_likert",
stack_var = "socioeconomic_status",
title = "Satisfaction by socioeconomic status",
subtitle = "",
x_label = "Satisfaction with treatment",
y_label = "Total responses",
stack_label = "SE status",
stacked_type = "normal",
include_na = TRUE
)
print(dummy1)Example 2: Using more complex data + binningGoal: Show the proportional distribution of familiarity with chatbots across different age groups.We are going to bin the stacked variable (age)

Note: we need to define mappings and orders in the environment
familiarity_mapping <- list(
"1" = "Not at all familiar with", "2" = "unfamiliar", "3" = "Slightly unfamiliar",
"4" = "Neutral", "5" = "Slightly familiar", "6" = "Familiar", "7" = "Very familiar with"
)
familiarity_order <- c(
"Not at all familiar with", "unfamiliar", "Slightly unfamiliar",
"Neutral", "Slightly familiar", "Familiar", "Very familiar with"
)Define breaks, bin labels, and order for the stack_var

age_numeric_breaks <- c(-Inf, 25, 35, 45, 55, 65, Inf) # Define your income ranges
age_bins <- c("Under 25", "25 to 34", "35 to 44", "45 to 54", "55 to 64", "65+") # Custom labels for these ranges
age_order <- age_bins # Order should follow the labelsCall the function

algosoc_kai5 <- create_stackedbar(
data = algosoc,
x_var = "KAI5", # X-axis will be familiarity with chatbots
stack_var = "leeftijd",   # Age to be stacked and binned
title = "Familiarity with chatbots",
subtitle = "Age is binned into categories and stacked",
x_label = "Familiarity",
y_label = "Number of Respondents",
stack_label = "Age",
stacked_type = "normal",Arguments for the X-axis (familiarity with chatbots)

x_map_values = familiarity_mapping,
x_order = familiarity_order,Arguments for the stacked variable (age)

stack_breaks = age_numeric_breaks,         # Provide the numeric cut points for stack_var
stack_bin_labels = age_bins, # Provide custom labels for the stack_var bins
stack_order = age_order           # Order the stacks by these custom labels
)Display the plot

algosoc_kai5
}
\description{
This function creates a stacked barchart for survey data. It
handles raw (unaggregated) data, counting the occurrences of
categories, supporting ordered factors, allowing numerical x-axis
and stacked variables to be binned into custom groups, and
enables renaming of categorical values for display. It can also
handle SPSS (.sav) columns automatically.

#' @details This function performs the following steps
\enumerate{
\item \strong{Input Validation:} Checks if the provided \code{data} is a data frame and if \code{x_var} and \code{stack_var} columns exist.
\item \strong{Data Copy:} Creates a mutable copy of the input \code{data} to perform transformations without affecting the original.
\item \strong{Handle 'haven_labelled' Columns:} If \code{haven} package is available, it detects if \code{x_var} or \code{stack_var} are of class \code{haven_labelled} (common for data imported from SPSS/Stata/SAS). If so, it converts them to standard R factors, using their underlying numeric values as levels (e.g., a '1' that was labeled "Male" will become a factor level "1"). This ensures \code{recode} can operate correctly.
\item \strong{Apply Value Mapping (\code{x_map_values}, \code{stack_map_values}):} If provided, \code{x_map_values} and \code{stack_map_values} (named lists, e.g., \code{list("1"="Male")}) are used to rename the values in \code{x_var} and \code{stack_var} respectively. This is useful for converting numeric codes or abbreviations into descriptive labels. If the column is a factor, it's temporarily converted to character to ensure \code{dplyr::recode} works reliably on the values.
\item \strong{Handle Binning (\code{x_breaks}, \code{x_bin_labels}, \code{stack_breaks}, \code{stack_bin_labels}):}
\itemize{
\item If \code{x_var} (or \code{stack_var}) is numeric and corresponding \verb{_breaks} are provided, the function uses \code{base::cut()} to discretize the numeric variable into bins.
\item \verb{_bin_labels} can be supplied to give custom names to these bins (e.g., "18-24" instead of "(17,25]"). If not provided, \code{cut()} generates default labels.
\item A temporary column (e.g., \code{.x_var_binned}) is created to hold the binned values, and this temporary column is then used for plotting.
}
\item \strong{Data Aggregation and Final Factor Handling:}
\itemize{
\item The data is transformed using \code{dplyr::mutate} to ensure \code{x_var} and \code{stack_var} (or their binned versions) are treated as factors. If \code{include_na = TRUE}, missing values are converted into an explicit "(NA)" factor level.
\item \code{dplyr::count()} is then used to aggregate the data, counting occurrences for each unique combination of \code{x_var} and \code{stack_var}. This creates the \code{n} column required for \code{highcharter}.
}
\item \strong{Apply Custom Ordering (\code{x_order}, \code{stack_order}):} If provided, \code{x_order} and \code{stack_order} are used to set the display order of the factor levels for the X-axis and stack categories, respectively. This is essential for ordinal scales (e.g., Likert scales) or custom desired sorting. Levels not found in the order vector are appended at the end.
\item \strong{Highcharter Chart Generation:} The aggregated \code{plot_data} is passed to \code{highcharter::hchart()} to create the base stacked column chart.
\item \strong{Chart Customization:} Titles, subtitles, axis labels, stacking type (normal vs. percent), data labels, legend titles, tooltips, and custom color palettes are applied based on the function's arguments.
\item \strong{Return Value:} The function returns a \code{highcharter} plot object, which can be printed directly to display the interactive chart.
}
}
