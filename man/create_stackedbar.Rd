% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_stackedbar.R, R/viz.R
\name{create_stackedbar}
\alias{create_stackedbar}
\title{Create a Stacked Bar Chart}
\usage{
create_stackedbar(
  data,
  x_var,
  y_var = NULL,
  stack_var,
  title = NULL,
  subtitle = NULL,
  x_label = NULL,
  y_label = NULL,
  stack_label = NULL,
  stacked_type = c("normal", "percent"),
  tooltip_prefix = "",
  tooltip_suffix = "",
  color_palette = NULL,
  stack_order = NULL,
  x_order = NULL,
  include_na = FALSE,
  x_breaks = NULL,
  x_bin_labels = NULL,
  x_map_values = NULL,
  stack_breaks = NULL,
  stack_bin_labels = NULL,
  stack_map_values = NULL
)

create_stackedbar(
  data,
  x_var,
  y_var = NULL,
  stack_var,
  title = NULL,
  subtitle = NULL,
  x_label = NULL,
  y_label = NULL,
  stack_label = NULL,
  stacked_type = c("normal", "percent"),
  tooltip_prefix = "",
  tooltip_suffix = "",
  color_palette = NULL,
  stack_order = NULL,
  x_order = NULL,
  include_na = FALSE,
  x_breaks = NULL,
  x_bin_labels = NULL,
  x_map_values = NULL,
  stack_breaks = NULL,
  stack_bin_labels = NULL,
  stack_map_values = NULL
)
}
\arguments{
\item{data}{A data frame containing the raw survey data (e.g., one row per respondent).}

\item{x_var}{The name of the column to be plotted on the X-axis (as a string).
This typically represents a demographic variable or a question.}

\item{y_var}{Optional. The name of the column that already contains the counts
or values for the y-axis (as a string). If \code{NULL} (default),
the function will internally count the occurrences of \code{x_var} and \code{stack_var}.
Only provide this if your \code{data} is already aggregated.}

\item{stack_var}{The name of the column whose unique values will define the
stacks within each bar (as a string). This is often a
Likert scale, an agreement level, or another categorical response.}

\item{title}{Optional. The main title of the chart (as a string).}

\item{subtitle}{Optional. A subtitle for the chart (as a string).}

\item{x_label}{Optional. The label for the X-axis (as a string). Defaults
to \code{x_var} or \code{x_var (Binned)}.}

\item{y_label}{Optional. The label for the Y-axis (as a string). Defaults
to "Number of Respondents" or "Percentage of Respondents".}

\item{stack_label}{Optional. The title for the stack legend (as a string).
Defaults to \code{stack_var} or \code{stack_var (Binned)}.}

\item{stacked_type}{Optional. The type of stacking. Can be "normal" (counts)
or "percent" (100\% stacked). Defaults to "normal".}

\item{tooltip_prefix}{Optional. A string to prepend to values in tooltips.}

\item{tooltip_suffix}{Optional. A string to append to values in tooltips.}

\item{color_palette}{Optional. A character vector of colors to use for the
stacks. If NULL, highcharter's default palette is used.
Consider ordering colors to match \code{stack_order}.}

\item{stack_order}{Optional. A character vector specifying the desired order
of the \code{stack_var} levels. This is crucial for ordinal
scales (e.g., Likert 1-7). If NULL, default factor order
or alphabetical will be used. Levels not found in data
will be ignored.}

\item{x_order}{Optional. A character vector specifying the desired order
of the \code{x_var} levels. If NULL, default factor order
or alphabetical will be used.}

\item{include_na}{Logical. If TRUE, explicit "(NA)" categories will be shown
in counts for \code{x_var} and \code{stack_var}. If FALSE (default),
rows with NA in \code{x_var} or \code{stack_var} are dropped.}

\item{x_breaks}{Optional. A numeric vector of cut points for \code{x_var} if
it is a continuous variable and you want to bin it.
e.g., \code{c(16, 24, 33, 42, 51, 60, Inf)}.}

\item{x_bin_labels}{Optional. A character vector of labels for the bins
created by \code{x_breaks}. Must be one less than the number
of breaks (or same if Inf is last break).}

\item{x_map_values}{Optional. A named list (e.g., \code{list("1" = "Female", "2" = "Male")})
to rename values within \code{x_var} for display. Original values
should be names, new labels should be values.}

\item{stack_breaks}{Optional. A numeric vector of cut points for \code{stack_var} if
it is a continuous variable and you want to bin it.}

\item{stack_bin_labels}{Optional. A character vector of labels for the bins
created by \code{stack_breaks}. Must be one less than the number
of breaks (or same if Inf is last break).}

\item{stack_map_values}{Optional. A named list (e.g., \code{list("1" = "Strongly Disagree", "7" = "Strongly Agree")})
to rename values within \code{stack_var} for display.}

\item{x_tooltip_suffix}{Optional. A string to append to x-axis values in tooltips.}

\item{na_label_x}{Optional string. Custom label for NA values in x_var. Defaults to "(Missing)".}

\item{na_label_stack}{Optional string. Custom label for NA values in stack_var. Defaults to "(Missing)".}
}
\value{
An interactive \code{highcharter} bar chart plot object.

An interactive \code{highcharter} bar chart plot object.
}
\description{
This function creates a stacked barchart for survey data. It
handles raw (unaggregated) data, counting the occurrences of
categories, supporting ordered factors, allowing numerical x-axis
and stacked variables to be binned into custom groups, and
enables renaming of categorical values for display. It can also
handle SPSS (.sav) columns automatically.

This function creates a stacked barchart for survey data. It
handles raw (unaggregated) data, counting the occurrences of
categories, supporting ordered factors, allowing numerical x-axis
and stacked variables to be binned into custom groups, and
enables renaming of categorical values for display. It can also
handle SPSS (.sav) columns automatically.

#' @details This function performs the following steps
\enumerate{
\item \strong{Input Validation:} Checks if the provided \code{data} is a data frame and if \code{x_var} and \code{stack_var} columns exist.
\item \strong{Data Copy:} Creates a mutable copy of the input \code{data} to perform transformations without affecting the original.
\item \strong{Handle 'haven_labelled' Columns:} If \code{haven} package is available, it detects if \code{x_var} or \code{stack_var} are of class \code{haven_labelled} (common for data imported from SPSS/Stata/SAS). If so, it converts them to standard R factors, using their underlying numeric values as levels (e.g., a '1' that was labeled "Male" will become a factor level "1"). This ensures \code{recode} can operate correctly.
\item \strong{Apply Value Mapping (\code{x_map_values}, \code{stack_map_values}):} If provided, \code{x_map_values} and \code{stack_map_values} (named lists, e.g., \code{list("1"="Male")}) are used to rename the values in \code{x_var} and \code{stack_var} respectively. This is useful for converting numeric codes or abbreviations into descriptive labels. If the column is a factor, it's temporarily converted to character to ensure \code{dplyr::recode} works reliably on the values.
\item \strong{Handle Binning (\code{x_breaks}, \code{x_bin_labels}, \code{stack_breaks}, \code{stack_bin_labels}):}
\itemize{
\item If \code{x_var} (or \code{stack_var}) is numeric and corresponding \verb{_breaks} are provided, the function uses \code{base::cut()} to discretize the numeric variable into bins.
\item \verb{_bin_labels} can be supplied to give custom names to these bins (e.g., "18-24" instead of "(17,25]"). If not provided, \code{cut()} generates default labels.
\item A temporary column (e.g., \code{.x_var_binned}) is created to hold the binned values, and this temporary column is then used for plotting.
}
\item \strong{Data Aggregation and Final Factor Handling:}
\itemize{
\item The data is transformed using \code{dplyr::mutate} to ensure \code{x_var} and \code{stack_var} (or their binned versions) are treated as factors. If \code{include_na = TRUE}, missing values are converted into an explicit "(NA)" factor level.
\item \code{dplyr::count()} is then used to aggregate the data, counting occurrences for each unique combination of \code{x_var} and \code{stack_var}. This creates the \code{n} column required for \code{highcharter}.
}
\item \strong{Apply Custom Ordering (\code{x_order}, \code{stack_order}):} If provided, \code{x_order} and \code{stack_order} are used to set the display order of the factor levels for the X-axis and stack categories, respectively. This is essential for ordinal scales (e.g., Likert scales) or custom desired sorting. Levels not found in the order vector are appended at the end.
\item \strong{Highcharter Chart Generation:} The aggregated \code{plot_data} is passed to \code{highcharter::hchart()} to create the base stacked column chart.
\item \strong{Chart Customization:} Titles, subtitles, axis labels, stacking type (normal vs. percent), data labels, legend titles, tooltips, and custom color palettes are applied based on the function's arguments.
\item \strong{Return Value:} The function returns a \code{highcharter} plot object, which can be printed directly to display the interactive chart.
}
}
\details{
This function performs the following steps:
\enumerate{
\item \strong{Input Validation:} Checks if the provided \code{data} is a data frame and if \code{x_var} and \code{stack_var} columns exist.
\item \strong{Data Copy:} Creates a mutable copy of the input \code{data} to perform transformations without affecting the original.
\item \strong{Handle 'haven_labelled' Columns:} If \code{haven} package is available, it detects if \code{x_var} or \code{stack_var} are of class \code{haven_labelled} (common for data imported from SPSS/Stata/SAS). If so, it converts them to standard R factors, using their underlying numeric values as levels (e.g., a '1' that was labeled "Male" will become a factor level "1"). This ensures \code{recode} can operate correctly.
\item \strong{Apply Value Mapping (\code{x_map_values}, \code{stack_map_values}):} If provided, \code{x_map_values} and \code{stack_map_values} (named lists, e.g., \code{list("1"="Male")}) are used to rename the values in \code{x_var} and \code{stack_var} respectively. This is useful for converting numeric codes or abbreviations into descriptive labels. If the column is a factor, it's temporarily converted to character to ensure \code{dplyr::recode} works reliably on the values.
\item \strong{Handle Binning (\code{x_breaks}, \code{x_bin_labels}, \code{stack_breaks}, \code{stack_bin_labels}):}
\itemize{
\item If \code{x_var} (or \code{stack_var}) is numeric and corresponding \verb{_breaks} are provided, the function uses \code{base::cut()} to discretize the numeric variable into bins.
\item \verb{_bin_labels} can be supplied to give custom names to these bins (e.g., "18-24" instead of "(17,25]"). If not provided, \code{cut()} generates default labels.
\item A temporary column (e.g., \code{.x_var_binned}) is created to hold the binned values, and this temporary column is then used for plotting.
}
\item \strong{Data Aggregation and Final Factor Handling:}
\itemize{
\item The data is transformed using \code{dplyr::mutate} to ensure \code{x_var} and \code{stack_var} (or their binned versions) are treated as factors. If \code{include_na = TRUE}, missing values are converted into an explicit "(NA)" factor level.
\item \code{dplyr::count()} is then used to aggregate the data, counting occurrences for each unique combination of \code{x_var} and \code{stack_var}. This creates the \code{n} column required for \code{highcharter}.
}
\item \strong{Apply Custom Ordering (\code{x_order}, \code{stack_order}):} If provided, \code{x_order} and \code{stack_order} are used to set the display order of the factor levels for the X-axis and stack categories, respectively. This is essential for ordinal scales (e.g., Likert scales) or custom desired sorting. Levels not found in the order vector are appended at the end.
\item \strong{Highcharter Chart Generation:} The aggregated \code{plot_data} is passed to \code{highcharter::hchart()} to create the base stacked column chart.
\item \strong{Chart Customization:} Titles, subtitles, axis labels, stacking type (normal vs. percent), data labels, legend titles, tooltips, and custom color palettes are applied based on the function's arguments.
\item \strong{Return Value:} The function returns a \code{highcharter} plot object, which can be printed directly to display the interactive chart.
}
}
\examples{
# We will be using data from GSS for these examples.
# Make sure you have the data loaded:
data(gss_all)

# Filter to recent years and select relevant variables
gss_recent <- gss_all \%>\%
  filter(year >= 2010) \%>\%
  select(age, degree, happy, sex, race, year, polviews, attend)

# Example 1: Basic stacked bar - Education by Gender
education_order <- c("Lt High School", "High School", "Junior College", "Bachelor", "Graduate")

plot1 <- create_stackedbar(
  data = gss_recent,
  x_var = "degree",
  stack_var = "sex",
  title = "Educational Attainment by Gender",
  subtitle = "GSS respondents 2010-present",
  x_label = "Highest Degree Completed",
  y_label = "Number of Respondents",
  stack_label = "Gender",
  x_order = education_order,
)
plot1

# Example 2: Percentage stacked - Happiness by Education Level
plot2 <- create_stackedbar(
  data = gss_recent,
  x_var = "degree",
  stack_var = "happy",
  title = "Happiness Distribution Across Education Levels",
  subtitle = "Percentage breakdown within each education category",
  x_label = "Education Level",
  y_label = "Percentage of Respondents",
  stack_label = "Happiness Level",
  stacked_type = "percent",
  x_order = education_order,
  stack_order = c("Very Happy", "Pretty Happy", "Not Too Happy"),
  tooltip_suffix = "\%",
  color_palette = c("turquoise", "slateblue", "steelblue")
)
plot2

# Example 3: Age binning with political views
age_breaks <- c(18, 30, 45, 60, 75, Inf)
age_labels <- c("18-29", "30-44", "45-59", "60-74", "75+")

# Map political views to shorter labels
polviews_map <- list(
  "Extremely Liberal" = "Ext Liberal",
  "Liberal" = "Liberal",
  "Slightly Liberal" = "Sl Liberal",
  "Moderate" = "Moderate",
  "Slightly Conservative" = "Sl Conservative",
  "Conservative" = "Conservative",
  "Extremely Conservative" = "Ext Conservative"
)

plot3 <- create_stackedbar(
  data = gss_recent,
  x_var = "age",
  stack_var = "polviews",
  title = "Political Views by Age Group",
  subtitle = "Distribution of political ideology across age cohorts",
  x_label = "Age Group",
  stack_label = "Political Views",
  x_breaks = age_breaks,
  x_bin_labels = age_labels,
  stack_map_values = polviews_map,
  stacked_type = "percent",
  tooltip_suffix = "\%",
  x_tooltip_suffix = " years",
)
plot3

# Example 4: Including NA values with custom labels
plot4 <- create_stackedbar(
  data = gss_recent,
  x_var = "race",
  stack_var = "attend",
  title = "Religious Attendance by Race/Ethnicity",
  subtitle = "Including non-responses as explicit category",
  x_label = "Race/Ethnicity",
  stack_label = "Religious Attendance",
  include_na = TRUE,
  na_label_x = "Not Specified",
  na_label_stack = "No Answer",
  stacked_type = "percent",
  tooltip_suffix = "\%"
)
plot4

# Example 5: Using pre-aggregated data
# Create aggregated data first
education_gender_counts <- gss_recent \%>\%
  filter(!is.na(degree) & !is.na(sex)) \%>\%
  count(degree, sex, name = "respondent_count") \%>\%
  mutate(degree = factor(degree, levels = education_order))

plot5 <- create_stackedbar(
  data = education_gender_counts,
  x_var = "degree",
  y_var = "respondent_count",  # Use pre-computed counts
  stack_var = "sex",
  title = "Education by Gender (Pre-aggregated Data)",
  subtitle = "Using pre-computed counts",
  x_label = "Education Level",
  y_label = "Number of Respondents",
  stack_label = "Gender",
)
plot5

# Example 6: Complex mapping with custom ordering
# Map sex to more descriptive labels
sex_map <- list("Male" = "Men", "Female" = "Women")

plot6 <- create_stackedbar(
  data = gss_recent,
  x_var = "happy",
  stack_var = "sex",
  title = "Gender Distribution Across Happiness Levels",
  subtitle = "With custom gender labels and happiness ordering",
  x_label = "Self-Reported Happiness",
  stack_label = "Gender",
  x_order = c("Very Happy", "Pretty Happy", "Not Too Happy"),
  stack_map_values = sex_map,
  stack_order = c("Women", "Men"),
  stacked_type = "normal",
  tooltip_prefix = "Count: ",
)
plot6



TODO: actually make sure the dummy data is available. I also removed the library loading as it typically is assumed that you have your package (and all its dependencies) loaded in when using it.
# Using the provided dummy data R file
dummy1 <- create_stackedbar(
data = survey_data,
x_var = "satisfaction_likert",
stack_var = "socioeconomic_status",
title = "Satisfaction by socioeconomic status",
subtitle = "",
x_label = "Satisfaction with treatment",
y_label = "Total responses",
stack_label = "SE status",
stacked_type = "normal",
include_na = TRUE
)
print(dummy1)

# Example 2: Using more complex data + binning
# Goal: Show the proportional distribution of familiarity with chatbots across different age groups.
# We are going to bin the stacked variable (age)
Note: we need to define mappings and orders in the environment
familiarity_mapping <- list(
 "1" = "Not at all familiar with", "2" = "unfamiliar", "3" = "Slightly unfamiliar",
 "4" = "Neutral", "5" = "Slightly familiar", "6" = "Familiar", "7" = "Very familiar with"
 )
familiarity_order <- c(
 "Not at all familiar with", "unfamiliar", "Slightly unfamiliar",
 "Neutral", "Slightly familiar", "Familiar", "Very familiar with"
 )
# Define breaks, bin labels, and order for the stack_var
age_numeric_breaks <- c(-Inf, 25, 35, 45, 55, 65, Inf) # Define your income ranges
age_bins <- c("Under 25", "25 to 34", "35 to 44", "45 to 54", "55 to 64", "65+") # Custom labels for these ranges
age_order <- age_bins # Order should follow the labels
# Call the function
algosoc_kai5 <- create_stackedbar(
 data = algosoc,
 x_var = "KAI5", # X-axis will be familiarity with chatbots
 stack_var = "leeftijd",   # Age to be stacked and binned
 title = "Familiarity with chatbots",
 subtitle = "Age is binned into categories and stacked",
 x_label = "Familiarity",
 y_label = "Number of Respondents",
 stack_label = "Age",
 stacked_type = "normal",
 # Arguments for the X-axis (familiarity with chatbots)
 x_map_values = familiarity_mapping,
 x_order = familiarity_order,
 # Arguments for the stacked variable (age)
 stack_breaks = age_numeric_breaks,         # Provide the numeric cut points for stack_var
 stack_bin_labels = age_bins, # Provide custom labels for the stack_var bins
 stack_order = age_order           # Order the stacks by these custom labels
 )
# Display the plot
algosoc_kai5
}
