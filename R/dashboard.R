# Define a vector of hexadecimal color codes.
# These colors are used for styling plots generated by the functions below.
# Each color is assigned a comment indicating its general appearance.
thecolors <<- c(
  "#F7A35C",     # Light orange
  "#ADD8E6",     # Light blue
  "#E9BB97",     # Soft amber
  "#E4D354",     # Light mustard
  "#90EE90",     # Light green
  "#1F78B4",     # Bluish
  "#F4A8A8",     # Pale red
  "#C29EC4",     # Pastel purple
  "#FFD966",     # Light gold
  "#B2DFEE",     # Light sky blue
  "#FFB6C2",     # Light pink
  "#B0E0C6"      # Powder blue
)

# To view the defined colors, you would uncomment the line below:
# thecolors

# --------------------------------------------------------------------------
# Function: generate_general
# --------------------------------------------------------------------------
#' @title Generate a General Summary Bar Chart
#' @description This function takes a dataset and a range of variables to create
#'              a bar chart summarizing the means of these variables. It also
#'              includes error bars representing standard errors. The chart is
#'              ordered by the mean values of the variables.
#'
#' @param data A data frame containing the survey data.
#' @param var1 The starting variable name (unquoted) for the range of variables to be analyzed.
#'             The variables should be selectable using `select(data, var1:var2)`.
#' @param var2 The ending variable name (unquoted) for the range of variables to be analyzed.
#' @param thevarlabs A character vector of labels for the variables. The order of these
#'                   labels should correspond to the order of the variables selected by `var1:var2`.
#' @param thelabel A character string for the y-axis label.
#'                 Defaults to "<- 1: never     -     7: very often ->".
#'
#' @details The function performs the following steps:
#'          1. Selects the specified range of variables from the input `data`.
#'          2. Removes rows with any missing values in the selected variables.
#'          3. Calculates the mean, standard error (`std.error` function is assumed to be defined elsewhere),
#'             and count (n) for each variable.
#'          4. Assigns the provided `thevarlabs` to the variables.
#'          5. Reorders the variables (and their labels) based on their mean values in descending order.
#'          6. Stores the order of variable labels in a global variable `theorder`.
#'          7. Generates an interactive bar chart using `highcharter` where:
#'             - Bars represent the mean values.
#'             - Error bars represent mean +/- standard error.
#'             - Each bar has a distinct color from the `thecolors` vector.
#'             - Y-axis is scaled from 1 to 7.
#'             - A caption with the total number of observations (N) and a note about error bars is included.
#'
#' @return A `highchart` object representing the generated plot.
#'
#' @examples
#' # Assuming 'survey_data' is your data frame,
#' # 'q1' to 'q5' are your variables,
#' # and 'var_labels' is a vector of corresponding labels:
#' # generate_general(survey_data, q1, q5, var_labels)
#'
#' # To use a custom y-axis label:
#' # generate_general(survey_data, q1, q5, var_labels, "Custom Y-axis Label")
#'
#' Dependencies: dplyr, tidyr, highcharter, forcats
#'               (Note: `std.error` function needs to be defined in the environment)
generate_general <- function(data, var1, var2, thevarlabs, thelabel = "<- 1: never     -     7: very often ->") {

  # Select the specified range of variables and remove rows with NA values.
  # The commented out line `select(var1:var2, weight)` suggests that
  # weighted calculations were considered or used previously.
  fin <- data %>%
    select(var1:var2) %>%
    # select(var1:var2, weight) %>% # Option to include a weight column
    drop_na()

  # Calculate summary statistics for each variable.
  media_rec <- fin %>%
    # gather(key, value, -weight) %>% # Option for weighted gathering
    # Transform data from wide to long format.
    gather(key, value) %>%
    # Group by variable key.
    group_by(key) %>%
    # Calculate mean, standard error, and count for each variable.
    # The commented out `weighted.mean` suggests an option for weighted calculations.
    summarize(mean_val = mean(value, na.rm =T),
              # summarize(mean_val = weighted.mean(value, w = weight, na.rm =T), # Weighted mean
              sd_val = std.error(value), # Standard error (std.error function must be defined)
              n = n()) %>%
    # Ungroup the data.
    ungroup() %>%
    # Add variable labels.
    mutate(varlabs = thevarlabs) %>%
    # Reorder variable labels based on mean_val.
    mutate(varlabs = fct_reorder(varlabs, mean_val)) %>%
    # Arrange by descending order of reordered varlabs (which reflects mean_val).
    arrange(desc(varlabs))

  # Store the order of variable labels in a global variable `theorder`.
  # This can be used by other functions to maintain consistent ordering.
  theorder <<- media_rec %>% distinct(varlabs) %>% pull(varlabs)

  # Create a highcharter column chart.
  hchart(media_rec, "column", hcaes(x = varlabs, y = mean_val), name = "Mean") %>%
    # Set colors for the columns using the globally defined 'thecolors' vector.
    hc_colors(thecolors) %>%
    # Add error bars series to the chart.
    hc_add_series(
      media_rec,
      "errorbar",
      hcaes(y = mean_val,
            x = varlabs, low = mean_val - sd_val, # Lower bound of error bar
            high = mean_val + sd_val),           # Upper bound of error bar
      enableMouseTracking = TRUE, # Enable mouse tracking for tooltips on error bars
      showInLegend = FALSE,       # Do not show error bars in the legend
      name = ""                   # Set an empty name for the error bar series in tooltips if not customized
    ) %>%
    # Configure plot options.
    highcharter::hc_plotOptions(
      column = list(
        colorByPoint = TRUE  # Ensures that each bar gets a different color from 'thecolors'
      ),
      series = list(
        # Customize tooltip format for the main series.
        tooltip = list(pointFormat = '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.2f}</b><br/>')
      ),
      errorbar = list(
        color = "black",      # Color of the error bars
        stemWidth = 1         # Width of the stem of the error bars
      )
    ) %>%
    # Set x-axis options.
    highcharter::hc_xAxis(title = list(text = "")) %>% # No title for x-axis
    # Set y-axis options.
    hc_yAxis(
      title = list(text = thelabel), # Y-axis title from parameter
      max = 7, min = 1               # Set y-axis limits
    )  %>%
    # Disable the legend.
    hc_legend(enabled = FALSE)   %>%
    # Add a caption to the chart.
    hc_caption(
      text = paste0("<em>N = ", nrow(fin), ". Foutbalken tonen standaardfouten.</em>"), # Caption text with sample size
      align = "right",  # Align caption to the right
      style = list(fontSize = '10px', color = 'lightgrey') # Style for the caption
    )
}


# --------------------------------------------------------------------------
# Function: by_age
# --------------------------------------------------------------------------
#' @title Generate Bar Chart of Means by Age Groups
#' @description This function creates a grouped bar chart showing the means of
#'              specified variables, broken down by age groups. Error bars
#'              representing standard errors are included.
#'
#' @param data A data frame containing the survey data. Must include an `age_groups` column.
#' @param var1 The starting variable name (unquoted) for the range of variables to be analyzed.
#' @param var2 The ending variable name (unquoted) for the range of variables to be analyzed.
#' @param thevarlabs A character vector of labels for the variables. The order should
#'                   correspond to `var1:var2`.
#' @param thelabel A character string for the y-axis label.
#'                 Defaults to "<- 1: never     -     7: very often ->".
#'
#' @details The function performs these steps:
#'          1. Creates a mapping between variable names and `thevarlabs`.
#'          2. Selects `var1:var2` and the `age_groups` column, then removes NAs.
#'          3. Calculates mean, standard error, and count for each variable, grouped by `age_groups`.
#'          4. Joins the variable labels.
#'          5. Orders the variables based on the global `theorder` (set by `generate_general` or similar).
#'          6. Generates a grouped column chart using `highcharter`:
#'             - Columns represent mean values for each age group within each variable.
#'             - Error bars (mean +/- SE) are linked to their respective columns.
#'             - Y-axis is scaled from 1 to 7.
#'             - A legend for age groups is displayed.
#'             - A caption with N and error bar information is included.
#'
#' @return A `highchart` object representing the grouped bar chart.
#'
#' @examples
#' # Assuming 'survey_data' includes 'q1'-'q5', 'age_groups',
#' # and 'var_labels' corresponds to 'q1'-'q5'.
#' # `theorder` should exist from a previous call to `generate_general`.
#' # by_age(survey_data, q1, q5, var_labels)
#'
#' Dependencies: dplyr, tidyr, highcharter, forcats
#'               (Note: `std.error` function needs to be defined;
#'               `theorder` global variable should exist)
by_age <- function(data, var1, var2, thevarlabs, thelabel = "<- 1: never     -     7: very often ->") {

  # Create a tibble mapping variable names (keys) to provided variable labels.
  varlabdat <- data %>%
    select(var1:var2) %>% # Select the specified range of variables
    names() %>%           # Get their names
    tibble(key = ., varlabs = thevarlabs) # Create a two-column tibble

  # The line below seems to be a commented-out check or reminder.
  # thevarlabs

  # Prepare the final dataset for plotting.
  # The commented-out line `mutate(varlabs = c("ChatGPT", "Midjourney")) %>%`
  # suggests a hardcoded label assignment which is not used here.
  fin <- data %>%
    # Select the specified range of variables and the 'age_groups' column.
    # The commented out line `select(var1:var2, age_groups, weight)` suggests
    # that weighted calculations were considered.
    select(var1:var2, age_groups) %>%
    # select(var1:var2, age_groups, weight) %>% # Option for weighted selection
    drop_na() # Remove rows with NA values in any of the selected columns.

  # Calculate summary statistics for each variable, grouped by age_groups.
  media_rec_ages <- fin %>%
    # Transform data from wide to long format, keeping 'age_groups' as a separate column.
    # The commented out line `gather(key, value, -age_groups, -weight)` is for weighted data.
    gather(key, value, -age_groups) %>%
    # gather(key, value, -age_groups, -weight) %>% # Option for weighted gathering
    # Group by variable key and age_groups.
    group_by(key, age_groups) %>%
    # Calculate mean, standard error, and count for each group.
    # The commented out `weighted.mean` is for weighted calculations.
    summarize(mean_val = mean(value, na.rm =T),
              # summarize(mean_val = weighted.mean(value, w = weight,na.rm =T), # Weighted mean
              sd_val = std.error(value), # Standard error
              n = n()) %>%
    # Ungroup the data.
    ungroup() %>%
    # Join with the variable labels created earlier.
    left_join(varlabdat) %>%
    # Convert 'varlabs' to a factor, ordered according to the global 'theorder' vector.
    # This ensures consistent ordering of variables across different charts.
    mutate(varlabs = factor(varlabs, levels = as.character(theorder))) %>%
    # Arrange by 'varlabs' (which respects 'theorder') and then by 'age_groups'.
    arrange(varlabs)%>%
    arrange(age_groups)

  # The lines below are commented-out development/debugging code.
  # mutate(varlabs = var_labels)
  # as.character(theorder)

  # Create a highcharter grouped column chart.
  # `id` is used to link error bars to these main series if multiple series are plotted without explicit grouping.
  # For grouped data, `linkedTo` with group matching is more typical for error bars.
  # Here, `id` values are static, assuming a fixed number of age groups for linking.
  hchart(
    media_rec_ages,
    "column",
    # hcaes(x = varlabs, y = mean_val), # This would be for a non-grouped chart
    hcaes(x = varlabs, y = mean_val, group = age_groups), # Group columns by 'age_groups'
    id = c("a", "b", "c", "d", "e", "f", "g") # IDs for series, assumes up to 7 age groups for linking.
  )  %>%

    # Add error bars series to the chart.
    hc_add_series(
      media_rec_ages,
      "errorbar",
      hcaes(y = mean_val,
            x = varlabs, low = mean_val - sd_val,    # Lower bound of error bar
            high = mean_val + sd_val,   # Upper bound of error bar
            group = age_groups),        # Group error bars similarly to columns
      # The commented out hcaes is an alternative specification.
      # hcaes(y = mean_val, x = key, low = mean_val - sd_val, high = mean_val + sd_val, group = Type),
      # Link error bars to the corresponding column series. The number of elements in `linkedTo`
      # should match the number of `id`s provided in the main hchart call.
      linkedTo = c("a", "b", "c", "d", "e", "f", "g"),
      enableMouseTracking = TRUE, # Enable tooltips for error bars
      showInLegend = FALSE        # Do not show error bars in the legend
    ) %>%
    # Configure plot options.
    highcharter::hc_plotOptions(
      series = list(
        # Customize tooltip format for the series.
        tooltip = list(pointFormat = '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.2f}</b><br/>')
      ),
      errorbar = list(
        color = "black",      # Color of the error bars
        # whiskerLength = 1, # Option for whisker length (not used)
        stemWidth = 1         # Width of the stem of the error bars
      )
    ) %>%
    # Set x-axis options.
    highcharter::hc_xAxis(title = list(text = "")) %>% # No title for x-axis
    # Set y-axis options.
    hc_yAxis(
      title = list(text = thelabel), # Y-axis title from parameter
      max = 7, min = 1               # Set y-axis limits
    ) %>%
    # Configure the legend.
    hc_legend(
      layout = "vertical",    # Layout of legend items
      align = "right",        # Horizontal alignment
      verticalAlign = "top",  # Vertical alignment
      floating = TRUE,        # Whether the legend should float over the chart
      y = 6                   # Vertical offset for the legend
    )   %>%
    # Add a caption to the chart.
    hc_caption(
      text = paste0("<em>N = ", nrow(fin), ". Foutbalken tonen standaardfouten.</em>"), # Caption text with sample size
      align = "right",  # Align caption to the right
      style = list(fontSize = '10px', color = 'lightgrey') # Style for the caption
    )

}


# --------------------------------------------------------------------------
# Function: by_gender
# --------------------------------------------------------------------------
#' @title Generate Bar Chart of Means by Gender
#' @description This function creates a grouped bar chart displaying the means of
#'              specified variables, broken down by gender. It includes error bars
#'              for standard errors.
#'
#' @param data A data frame with survey data. Must include a `geslacht` (gender) column.
#' @param var1 The starting variable name (unquoted) for the range.
#' @param var2 The ending variable name (unquoted) for the range.
#' @param thevarlabs A character vector of labels for the variables.
#' @param thelabel A character string for the y-axis label.
#'                 Defaults to "<- 1: never     -     7: very often ->".
#'
#' @details Steps:
#'          1. Maps variable names to `thevarlabs`.
#'          2. Converts `geslacht` to labels (using `sjmisc::to_label`).
#'          3. Selects variables `var1:var2` and `geslacht`, then removes NAs.
#'             (Commented code suggests internationalization of gender labels and reordering).
#'          4. Calculates mean, SE, and N for each variable, grouped by `geslacht`.
#'          5. Joins variable labels and orders them based on global `theorder`.
#'          6. Generates a grouped column chart using `highcharter`:
#'             - Columns are means per gender within each variable.
#'             - Error bars (mean +/- SE) are linked.
#'             - Y-axis is 1-7.
#'             - Legend for gender is shown.
#'             - Caption includes N and error bar details.
#'
#' @return A `highchart` object.
#'
#' @examples
#' # Assuming 'survey_data' has 'q1'-'q5', 'geslacht',
#' # and 'var_labels' for 'q1'-'q5'. `theorder` should exist.
#' # by_gender(survey_data, q1, q5, var_labels)
#'
#' Dependencies: dplyr, tidyr, highcharter, forcats, sjmisc
#'               (Note: `std.error` function defined elsewhere; `theorder` global variable)
by_gender <- function(data, var1, var2, thevarlabs, thelabel = "<- 1: never     -     7: very often ->") {

  # Create a tibble mapping variable names (keys) to provided variable labels.
  varlabdat <- data %>%
    select(var1:var2) %>% # Select the specified range of variables
    names() %>%           # Get their names
    tibble(key = ., varlabs = thevarlabs) # Create a two-column tibble

  # Prepare the final dataset for plotting.
  fin <- data %>%
    # Convert the 'geslacht' (gender) column from coded values to labels.
    # `sjmisc::to_label` is used, implying 'geslacht' might be a factor with value labels.
    # TODO: this stuff cant be harcoded
    mutate(geslacht = sjmisc::to_label(geslacht)) %>%
    # Select the specified range of variables and the 'geslacht' column.
    select(var1:var2, geslacht) %>%
    # Remove rows with NA values in any of the selected columns.
    drop_na() #%>%
  # Commented out section for transforming gender labels and reordering.
  # This might be used for internationalization or specific ordering of gender categories.
  # mutate(geslacht = case_when(
  #    geslacht == "Vrouw" ~ "Woman",
  #    geslacht == "Anders" ~ "Other",
  #    T ~ geslacht # Keeps original if not "Vrouw" or "Anders"
  # )) %>%
  # mutate(geslacht = fct_relevel(geslacht, c("Man", "Woman", "Other"))) %>% # Reorder gender levels
  # arrange(geslacht) # Arrange data by gender

  # Calculate summary statistics for each variable, grouped by geslacht.
  media_rec_genders <- fin %>%
    drop_na() %>% # An additional drop_na, likely redundant if 'fin' is already handled.
    # Transform data from wide to long format, keeping 'geslacht' as a separate column.
    gather(key, value, -geslacht) %>%
    # Group by variable key and geslacht.
    group_by(key, geslacht) %>%
    # Calculate mean, standard error, and count for each group.
    summarize(mean_val = mean(value, na.rm =T),
              sd_val = std.error(value), # Standard error
              n = n()) %>%
    # Ungroup the data.
    ungroup() %>%
    # Join with the variable labels created earlier.
    left_join(varlabdat) %>%
    # Convert 'varlabs' to a factor, ordered according to the global 'theorder' vector.
    mutate(varlabs = factor(varlabs, levels = as.character(theorder))) %>%
    # Arrange by 'varlabs' (which respects 'theorder').
    arrange(varlabs)

  # Create a highcharter grouped column chart.
  # `id` is used to link error bars. Assumes up to 3 gender categories for linking.
  hchart(
    media_rec_genders,
    "column",
    # hcaes(x = varlabs, y = mean_val), # For non-grouped chart
    hcaes(x = varlabs, y = mean_val, group = geslacht), # Group columns by 'geslacht'
    id = c("a", "b", "c") # IDs for series, assumes up to 3 gender groups for linking.
  ) %>%

    # Add error bars series to the chart.
    hc_add_series(
      media_rec_genders,
      "errorbar",
      hcaes(y = mean_val,
            x = varlabs, low = mean_val - sd_val,    # Lower bound of error bar
            high = mean_val + sd_val,   # Upper bound of error bar
            group = geslacht),        # Group error bars similarly to columns
      # The commented out hcaes is an alternative specification.
      # hcaes(y = mean_val, x = key, low = mean_val - sd_val, high = mean_val + sd_val, group = Type),
      # Link error bars to the corresponding column series.
      linkedTo = c("a", "b", "c"),
      enableMouseTracking = TRUE, # Enable tooltips for error bars
      showInLegend = FALSE        # Do not show error bars in the legend
    ) %>%
    # Configure plot options.
    highcharter::hc_plotOptions(
      series = list(
        # Customize tooltip format for the series.
        tooltip = list(pointFormat = '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.2f}</b><br/>')
      ),
      errorbar = list(
        color = "black",      # Color of the error bars
        # whiskerLength = 1, # Option for whisker length
        stemWidth = 1         # Width of the stem of the error bars
      )
    ) %>%
    # Set x-axis options.
    highcharter::hc_xAxis(title = list(text = "")) %>% # No title for x-axis
    # Set y-axis options.
    hc_yAxis(
      title = list(text = thelabel), # Y-axis title from parameter
      max = 7, min = 1               # Set y-axis limits
    ) %>%
    # Configure the legend.
    hc_legend(
      layout = "vertical",    # Layout of legend items
      align = "right",        # Horizontal alignment
      verticalAlign = "top",  # Vertical alignment
      floating = TRUE,        # Whether the legend should float over the chart
      y = 6                   # Vertical offset for the legend
    ) %>%
    # Add a caption to the chart.
    hc_caption(
      text = paste0("<em>N = ", nrow(fin), ". Foutbalken tonen standaardfouten.</em>"), # Caption text
      align = "right",  # Align caption to the right
      style = list(fontSize = '10px', color = 'lightgrey') # Style for the caption
    )

}


# --------------------------------------------------------------------------
# Function: by_edu
# --------------------------------------------------------------------------
#' @title Generate Bar Chart of Means by Education Level
#' @description This function creates a grouped bar chart illustrating the means
#'              of specified variables, categorized by education level (`oplcat`).
#'              Error bars (standard errors) are included.
#'
#' @param data A data frame with survey data. Must include an `oplcat` (education category) column.
#' @param var1 The starting variable name (unquoted).
#' @param var2 The ending variable name (unquoted).
#' @param thevarlabs A character vector of labels for the variables.
#' @param thelabel A character string for the y-axis label.
#'                 Defaults to "<- 1: never     -     7: very often ->".
#'
#' @details Steps:
#'          1. Maps variable names to `thevarlabs`.
#'          2. Processes `oplcat`: removes NAs, converts to labels (using `sjmisc::to_label`).
#'             (Commented code shows potential for renaming/reordering education levels).
#'          3. Selects `var1:var2` and processed `oplcat`, then removes NAs.
#'          4. Calculates mean, SE, and N for each variable, grouped by `oplcat`.
#'          5. Joins variable labels and orders them based on global `theorder`.
#'          6. Generates a grouped column chart using `highcharter`:
#'             - Columns are means per education level within each variable.
#'             - Error bars (mean +/- SE) are linked.
#'             - Y-axis is 1-7.
#'             - Legend for education levels is shown.
#'             - Caption includes N and error bar details.
#'
#' @return A `highchart` object.
#'
#' @examples
#' # Assuming 'survey_data' has 'q1'-'q5', 'oplcat',
#' # and 'var_labels' for 'q1'-'q5'. `theorder` should exist.
#' # by_edu(survey_data, q1, q5, var_labels)
#'
#' Dependencies: dplyr, tidyr, highcharter, forcats, sjmisc
#'               (Note: `std.error` function defined elsewhere; `theorder` global variable)
by_edu <- function(data, var1, var2, thevarlabs, thelabel = "<- 1: never     -     7: very often ->") {

  # Create a tibble mapping variable names (keys) to provided variable labels.
  varlabdat <- data %>%
    select(var1:var2) %>% # Select the specified range of variables
    names() %>%           # Get their names
    tibble(key = ., varlabs = thevarlabs) # Create a two-column tibble

  # Commented out section defining 'education_levels'.
  # education_levels <- c("Primary (basisonderwijs)",
  #                       "Pre-Vocational (vmbo)",
  #                       "Secondary (havo/vwo)",
  #                       "Vocational (mbo)",
  #                       "Applied Sciences (hbo)",
  #                       "University (wo)") %>%
  #   tibble(eng = ., oplcat = c("basisonderwijs",
  #                              "vmbo",
  #                              "havo/vwo",
  #                              "mbo",
  #                              "hbo",
  #                              "wo"))


  # Prepare the final dataset for plotting.
  fin <- data %>%
    drop_na(oplcat) %>% # Remove rows where 'oplcat' (education category) is NA.
    # count(oplcat) %>% # Commented out: would count occurrences of each oplcat.
    # Convert 'oplcat' from coded values to labels using sjmisc::to_label.
    mutate(oplcat = sjmisc::to_label(oplcat)) %>%
    # left_join(education_levels) %>% # Commented out: join with predefined education levels.
    # mutate(oplcat = eng) %>% # Commented out: use English labels from 'education_levels'.
    # Commented out: Relevel 'oplcat' factor for specific ordering.
    # mutate(oplcat = fct_relevel(oplcat, c("Primary (basisonderwijs)",
    #                                      "Pre-Vocational (vmbo)",
    #                                      "Secondary (havo/vwo)",
    #                                      "Vocational (mbo)",
    #                                      "Applied Sciences (hbo)",
    #                                      "University (wo)"))) %>%
    # Select the specified range of variables and the 'oplcat' column.
    select(var1:var2, oplcat) %>%
    # Remove rows with NA values in any of the selected columns.
    drop_na()

  # Calculate summary statistics for each variable, grouped by oplcat.
  media_rec_edu <- fin %>%
    # Transform data from wide to long format, keeping 'oplcat' as a separate column.
    gather(key, value, -oplcat) %>%
    # Group by variable key and oplcat.
    group_by(key, oplcat) %>%
    # Calculate mean, standard error, and count for each group.
    summarize(mean_val = mean(value, na.rm =T),
              sd_val = std.error(value), # Standard error
              n = n()) %>%
    # Ungroup the data.
    ungroup() %>%
    # Join with the variable labels created earlier.
    left_join(varlabdat) %>%
    # Convert 'varlabs' to a factor, ordered according to the global 'theorder' vector.
    mutate(varlabs = factor(varlabs, levels = as.character(theorder))) %>%
    # Arrange by 'varlabs' (which respects 'theorder').
    arrange(varlabs)
  # mutate(varlabs = var_labels) # Commented out alternative labeling

  # Create a highcharter grouped column chart.
  # `id` is used to link error bars. Assumes up to 6 education categories for linking.
  hchart(
    media_rec_edu,
    "column",
    # hcaes(x = varlabs, y = mean_val), # For non-grouped chart
    hcaes(x = varlabs, y = mean_val, group = oplcat), # Group columns by 'oplcat'
    id = c("a", "b", "c", "d", "e", "f") # IDs for series, assumes up to 6 edu groups for linking.
  ) %>%

    # Add error bars series to the chart.
    hc_add_series(
      media_rec_edu,
      "errorbar",
      hcaes(y = mean_val,
            x = varlabs, low = mean_val - sd_val,    # Lower bound of error bar
            high = mean_val + sd_val,   # Upper bound of error bar
            group = oplcat),        # Group error bars similarly to columns
      # The commented out hcaes is an alternative specification.
      # hcaes(y = mean_val, x = key, low = mean_val - sd_val, high = mean_val + sd_val, group = Type),
      # Link error bars to the corresponding column series.
      linkedTo = c("a", "b", "c", "d", "e", "f"),
      enableMouseTracking = TRUE, # Enable tooltips for error bars
      showInLegend = FALSE        # Do not show error bars in the legend
    ) %>%
    # Configure plot options.
    highcharter::hc_plotOptions(
      series = list(
        # Customize tooltip format for the series.
        tooltip = list(pointFormat = '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.2f}</b><br/>')
      ),
      errorbar = list(
        color = "black",      # Color of the error bars
        # whiskerLength = 1, # Option for whisker length
        stemWidth = 1         # Width of the stem of the error bars
      )
    ) %>%
    # Set x-axis options.
    highcharter::hc_xAxis(title = list(text = "")) %>% # No title for x-axis
    # Set y-axis options.
    hc_yAxis(
      title = list(text = thelabel), # Y-axis title from parameter
      max = 7, min = 1               # Set y-axis limits
    ) %>%
    # Configure the legend.
    hc_legend(
      layout = "vertical",    # Layout of legend items
      align = "right",        # Horizontal alignment
      verticalAlign = "top",  # Vertical alignment
      floating = TRUE,        # Whether the legend should float over the chart
      y = 6                   # Vertical offset for the legend
    ) %>%
    # Add a caption to the chart.
    hc_caption(
      text = paste0("<em>N = ", nrow(fin), ". Foutbalken tonen standaardfouten.</em>"), # Caption text
      align = "right",  # Align caption to the right
      style = list(fontSize = '10px', color = 'lightgrey') # Style for the caption
    )
}


# --------------------------------------------------------------------------
# Function: by_pol
# --------------------------------------------------------------------------
#' @title Generate Bar Chart of Means by Political Category
#' @description This function produces a grouped bar chart showing the means of
#'              specified variables, broken down by political category (`pol_cat`).
#'              Error bars (standard errors) are included.
#'
#' @param data A data frame. Must include a `pol_cat` (political category) column.
#' @param var1 The starting variable name (unquoted).
#' @param var2 The ending variable name (unquoted).
#' @param thevarlabs A character vector of labels for the variables.
#' @param thelabel A character string for the y-axis label.
#'                 Defaults to "<- 1: never     -     7: very often ->".
#'
#' @details Steps:
#'          1. Maps variable names to `thevarlabs`.
#'          2. Converts `pol_cat` to labels (using `sjmisc::to_label`).
#'          3. Selects `var1:var2` and `pol_cat`, then removes NAs.
#'          4. Calculates mean, SE, and N for each variable, grouped by `pol_cat`.
#'          5. Joins variable labels, orders them by global `theorder`, and relevels `pol_cat`.
#'          6. Generates a grouped column chart using `highcharter`:
#'             - Columns are means per political category within each variable.
#'             - Error bars (mean +/- SE) are linked.
#'             - Y-axis is 1-7.
#'             - Legend for political categories is shown.
#'             - Caption includes N, error bar details, and a note on `pol_cat` definition.
#'
#' @return A `highchart` object.
#'
#' @examples
#' # Assuming 'survey_data' has 'q1'-'q5', 'pol_cat',
#' # and 'var_labels' for 'q1'-'q5'. `theorder` should exist.
#' # by_pol(survey_data, q1, q5, var_labels)
#'
#' Dependencies: dplyr, tidyr, highcharter, forcats, sjmisc
#'               (Note: `std.error` function defined elsewhere; `theorder` global variable)
by_pol <- function(data, var1, var2, thevarlabs, thelabel = "<- 1: never     -     7: very often ->") {

  # Create a tibble mapping variable names (keys) to provided variable labels.
  varlabdat <- data %>%
    select(var1:var2) %>% # Select the specified range of variables
    names() %>%           # Get their names
    tibble(key = ., varlabs = thevarlabs) # Create a two-column tibble

  # Prepare the final dataset for plotting.
  fin <- data %>%
    # Convert 'pol_cat' (political category) from coded values to labels.
    # The original column seems to be `pol_cat` but it's assigned to `oplcat` here,
    # which might be a typo and should likely be `pol_cat = sjmisc::to_label(pol_cat)`.
    # Assuming it's intended to be `pol_cat`.
    mutate(pol_cat = sjmisc::to_label(pol_cat)) %>% # Corrected oplcat to pol_cat based on context
    # Select the specified range of variables and the 'pol_cat' column.
    select(var1:var2, pol_cat) %>%
    # Remove rows with NA values in any of the selected columns.
    drop_na()

  # Calculate summary statistics for each variable, grouped by pol_cat.
  media_rec_pol <- fin %>%
    # Transform data from wide to long format, keeping 'pol_cat' as a separate column.
    gather(key, value, -pol_cat) %>%
    # Group by variable key and pol_cat.
    group_by(key, pol_cat) %>%
    # Calculate mean, standard error, and count for each group.
    summarize(mean_val = mean(value, na.rm =T),
              sd_val = std.error(value), # Standard error
              n = n()) %>%
    # Ungroup the data.
    ungroup() %>%
    # Join with the variable labels created earlier.
    left_join(varlabdat) %>%
    # Convert 'varlabs' to a factor, ordered according to the global 'theorder' vector.
    mutate(varlabs = factor(varlabs, levels = as.character(theorder))) %>%
    # Arrange by 'varlabs' (which respects 'theorder').
    arrange(varlabs) %>%
    # Relevel 'pol_cat' factor for specific ordering (left, center, right).
    mutate(pol_cat = fct_relevel(pol_cat, c("left", "center", "right")))
  # mutate(varlabs = var_labels) # Commented out alternative labeling

  # Create a highcharter grouped column chart.
  # `id` is used to link error bars. Assumes up to 3 political categories.
  hchart(
    media_rec_pol,
    "column",
    # hcaes(x = varlabs, y = mean_val), # For non-grouped chart
    hcaes(x = varlabs, y = mean_val, group = pol_cat), # Group columns by 'pol_cat'
    id = c("a", "b", "c") # IDs for series, assumes 3 pol_cat groups for linking.
  ) %>%

    # Add error bars series to the chart.
    hc_add_series(
      media_rec_pol,
      "errorbar",
      hcaes(y = mean_val,
            x = varlabs, low = mean_val - sd_val,    # Lower bound of error bar
            high = mean_val + sd_val,   # Upper bound of error bar
            group = pol_cat),        # Group error bars similarly to columns
      # The commented out hcaes is an alternative specification.
      # hcaes(y = mean_val, x = key, low = mean_val - sd_val, high = mean_val + sd_val, group = Type),
      # Link error bars to the corresponding column series.
      linkedTo = c("a", "b", "c"),
      enableMouseTracking = TRUE, # Enable tooltips for error bars
      showInLegend = FALSE        # Do not show error bars in the legend
    ) %>%
    # Configure plot options.
    highcharter::hc_plotOptions(
      series = list(
        # Customize tooltip format for the series.
        tooltip = list(pointFormat = '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.2f}</b><br/>')
      ),
      errorbar = list(
        color = "black",      # Color of the error bars
        # whiskerLength = 1, # Option for whisker length
        stemWidth = 1         # Width of the stem of the error bars
      )
    ) %>%
    # Set x-axis options.
    highcharter::hc_xAxis(title = list(text = "")) %>% # No title for x-axis
    # Set y-axis options.
    hc_yAxis(
      title = list(text = thelabel), # Y-axis title from parameter
      max = 7, min = 1               # Set y-axis limits
    ) %>%
    # Configure the legend.
    hc_legend(
      layout = "vertical",    # Layout of legend items
      align = "right",        # Horizontal alignment
      verticalAlign = "top",  # Vertical alignment
      floating = TRUE,        # Whether the legend should float over the chart
      y = 6                   # Vertical offset for the legend
    ) %>%
    # Add a caption to the chart.
    hc_caption(
      text = paste0("<em>N = ", nrow(fin), ". Foutbalken tonen standaardfouten. Politics category is based on 10-scale: 0-3: left; 4-6: center; 7-10: right.</em>"), # Caption text
      align = "right",  # Align caption to the right
      style = list(fontSize = '10px', color = 'lightgrey') # Style for the caption
    )
}


# --------------------------------------------------------------------------
# Function: generate_general2
# --------------------------------------------------------------------------
#' @title Generate a General Summary Bar Chart for Three Specific Variables
#' @description This function is similar to `generate_general` but is designed
#'              to work with three explicitly named variables (`var1`, `var2`, `var3`)
#'              instead of a range. It creates a bar chart of means with error bars.
#'
#' @param data A data frame containing the survey data.
#' @param var1 The first variable name (unquoted).
#' @param var2 The second variable name (unquoted).
#' @param var3 The third variable name (unquoted).
#' @param thevarlabs A character vector of three labels for `var1`, `var2`, `var3` respectively.
#' @param thelabel A character string for the y-axis label.
#'                 Defaults to "<- 1: never     -     7: very often ->".
#'
#' @details The function:
#'          1. Selects the three specified variables.
#'          2. Removes rows with NAs.
#'          3. Calculates mean, standard error, and count for each of the three variables.
#'          4. Assigns `thevarlabs`.
#'          5. Reorders variables by mean (descending) and updates global `theorder`.
#'          6. Generates a `highcharter` column chart with means and error bars (mean +/- SE).
#'             Y-axis is 1-7. Caption includes N.
#'
#' @return A `highchart` object.
#'
#' @examples
#' # generate_general2(survey_data, q1, q2, q3, c("Label Q1", "Label Q2", "Label Q3"))
#'
#' Dependencies: dplyr, tidyr, highcharter, forcats
#'               (Note: `std.error` function defined elsewhere)
generate_general2 <- function(data, var1, var2, var3, thevarlabs, thelabel = "<- 1: never     -     7: very often ->") {

  # Select the three specified variables and remove rows with NA values.
  fin <- data %>%
    select(var1, var2, var3) %>% # Select the three specific columns
    drop_na()

  # Calculate summary statistics for each of the three variables.
  media_rec <- fin %>%
    gather() %>% # Transform data from wide to long format (implicit key and value columns)
    # Group by variable key.
    group_by(key) %>%
    # Calculate mean, standard error, and count for each variable.
    summarize(mean_val = mean(value, na.rm =T),
              sd_val = std.error(value), # Standard error
              n = n()) %>%
    # Ungroup the data.
    ungroup() %>%
    # Add variable labels.
    mutate(varlabs = thevarlabs) %>%
    # Reorder variable labels based on mean_val.
    mutate(varlabs = fct_reorder(varlabs, mean_val)) %>%
    # Arrange by descending order of reordered varlabs (which reflects mean_val).
    arrange(desc(varlabs))

  # Store the order of variable labels in a global variable `theorder`.
  theorder <<- media_rec %>% distinct(varlabs) %>% pull(varlabs)

  # Create a highcharter column chart.
  hchart(media_rec, "column", hcaes(x = varlabs, y = mean_val), name = "Mean") %>%
    # Set colors for the columns using the globally defined 'thecolors' vector.
    hc_colors(thecolors) %>%
    # Add error bars series to the chart.
    hc_add_series(
      media_rec,
      "errorbar",
      hcaes(y = mean_val,
            x = varlabs, low = mean_val - sd_val, # Lower bound of error bar
            high = mean_val + sd_val),           # Upper bound of error bar
      enableMouseTracking = TRUE, # Enable mouse tracking for tooltips
      showInLegend = FALSE,       # Do not show error bars in the legend
      name = ""                   # Empty name for error bar series
    ) %>%
    # Configure plot options.
    highcharter::hc_plotOptions(
      column = list(
        colorByPoint = TRUE  # Each bar gets a different color
      ),
      series = list(
        # Customize tooltip format.
        tooltip = list(pointFormat = '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.2f}</b><br/>')
      ),
      errorbar = list(
        color = "black",      # Color of the error bars
        stemWidth = 1         # Width of the stem of the error bars
      )
    ) %>%
    # Set x-axis options.
    highcharter::hc_xAxis(title = list(text = "")) %>% # No title for x-axis
    # Set y-axis options.
    hc_yAxis(
      title = list(text = thelabel), # Y-axis title from parameter
      max = 7, min = 1               # Set y-axis limits
    )  %>%
    # Disable the legend.
    hc_legend(enabled = FALSE)   %>%
    # Add a caption to the chart.
    hc_caption(
      text = paste0("<em>N = ", nrow(fin), ". Foutbalken tonen standaardfouten.</em>"), # Caption text
      align = "right",  # Align caption to the right
      style = list(fontSize = '10px', color = 'lightgrey') # Style for the caption
    )
}


# --------------------------------------------------------------------------
# Function: by_age2
# --------------------------------------------------------------------------
#' @title Generate Bar Chart of Means for Three Specific Variables by Age Groups
#' @description Similar to `by_age`, but for three explicitly named variables
#'              (`var1`, `var2`, `var3`). It creates a grouped bar chart of means
#'              by age group, with error bars.
#'
#' @param data A data frame. Must include `age_groups` and `var1`, `var2`, `var3`.
#' @param var1 The first variable name (unquoted).
#' @param var2 The second variable name (unquoted).
#' @param var3 The third variable name (unquoted).
#' @param thevarlabs A character vector of three labels for `var1`, `var2`, `var3`.
#' @param thelabel A character string for the y-axis label.
#'                 Defaults to "<- 1: never     -     7: very often ->".
#'
#' @details Steps:
#'          1. Maps variable names (`var1`, `var2`, `var3`) to `thevarlabs`.
#'          2. Selects `var1`, `var2`, `var3`, and `age_groups`, then removes NAs.
#'          3. Calculates mean, SE, N for each of the three variables, grouped by `age_groups`.
#'          4. Joins labels, orders variables by global `theorder`.
#'          5. Generates a `highcharter` grouped column chart (means per age group) with error bars.
#'             Y-axis 1-7. Legend for age groups. Caption with N.
#'
#' @return A `highchart` object.
#'
#' @examples
#' # `theorder` should exist.
#' # by_age2(survey_data, q1, q2, q3, c("LQ1", "LQ2", "LQ3"))
#'
#' Dependencies: dplyr, tidyr, highcharter, forcats
#'               (Note: `std.error` function defined elsewhere; `theorder` global variable)
by_age2 <- function(data, var1, var2, var3, thevarlabs, thelabel = "<- 1: never     -     7: very often ->") {

  # Create a tibble mapping the three variable names (keys) to provided variable labels.
  varlabdat <- data %>%
    select(var1, var2, var3) %>% # Select the three specific variables
    names() %>%                 # Get their names
    tibble(key = ., varlabs = thevarlabs) # Create a two-column tibble

  # Prepare the final dataset for plotting.
  fin <- data %>%
    # Select the three specified variables and the 'age_groups' column.
    select(var1, var2, var3, age_groups) %>%
    drop_na() # Remove rows with NA values in any of the selected columns.

  # Calculate summary statistics for each variable, grouped by age_groups.
  media_rec_ages <- fin %>%
    # Transform data from wide to long format, keeping 'age_groups' as a separate column.
    gather(key, value, -age_groups) %>%
    # Group by variable key and age_groups.
    group_by(key, age_groups) %>%
    # Calculate mean, standard error, and count for each group.
    summarize(mean_val = mean(value, na.rm =T),
              sd_val = std.error(value), # Standard error
              n = n()) %>%
    # Ungroup the data.
    ungroup() %>%
    # Join with the variable labels created earlier.
    left_join(varlabdat) %>%
    # Convert 'varlabs' to a factor, ordered according to the global 'theorder' vector.
    mutate(varlabs = factor(varlabs, levels = as.character(theorder))) %>%
    # Arrange by 'varlabs' (respecting 'theorder') and then by 'age_groups'.
    arrange(varlabs)%>%
    arrange(age_groups)

  # Commented out debugging/development lines
  # mutate(varlabs = var_labels)
  # as.character(theorder)

  # Create a highcharter grouped column chart.
  # `id` values are static, assuming a fixed number of age groups for linking error bars.
  hchart(
    media_rec_ages,
    "column",
    # hcaes(x = varlabs, y = mean_val), # For non-grouped chart
    hcaes(x = varlabs, y = mean_val, group = age_groups), # Group columns by 'age_groups'
    id = c("a", "b", "c", "d", "e", "f", "g") # IDs for series, assumes up to 7 age groups for linking.
  )  %>%

    # Add error bars series to the chart.
    hc_add_series(
      media_rec_ages,
      "errorbar",
      hcaes(y = mean_val,
            x = varlabs, low = mean_val - sd_val,    # Lower bound of error bar
            high = mean_val + sd_val,   # Upper bound of error bar
            group = age_groups),        # Group error bars similarly to columns
      # The commented out hcaes is an alternative specification.
      # hcaes(y = mean_val, x = key, low = mean_val - sd_val, high = mean_val + sd_val, group = Type),
      # Link error bars to the corresponding column series.
      linkedTo = c("a", "b", "c", "d", "e", "f", "g"),
      enableMouseTracking = TRUE, # Enable tooltips for error bars
      showInLegend = FALSE        # Do not show error bars in the legend
    ) %>%
    # Configure plot options.
    highcharter::hc_plotOptions(
      series = list(
        # Customize tooltip format for the series.
        tooltip = list(pointFormat = '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.2f}</b><br/>')
      ),
      errorbar = list(
        color = "black",      # Color of the error bars
        # whiskerLength = 1, # Option for whisker length
        stemWidth = 1         # Width of the stem of the error bars
      )
    ) %>%
    # Set x-axis options.
    highcharter::hc_xAxis(title = list(text = "")) %>% # No title for x-axis
    # Set y-axis options.
    hc_yAxis(
      title = list(text = thelabel), # Y-axis title from parameter
      max = 7, min = 1               # Set y-axis limits
    ) %>%
    # Configure the legend.
    hc_legend(
      layout = "vertical",    # Layout of legend items
      align = "right",        # Horizontal alignment
      verticalAlign = "top",  # Vertical alignment
      floating = TRUE,        # Whether the legend should float over the chart
      y = 6                   # Vertical offset for the legend
    )   %>%
    # Add a caption to the chart.
    hc_caption(
      text = paste0("<em>N = ", nrow(fin), ". Foutbalken tonen standaardfouten.</em>"), # Caption text
      align = "right",  # Align caption to the right
      style = list(fontSize = '10px', color = 'lightgrey') # Style for the caption
    )

}

# --------------------------------------------------------------------------
# Function: by_gender2
# --------------------------------------------------------------------------
#' @title Generate Bar Chart of Means for Three Specific Variables by Gender
#' @description Similar to `by_gender`, but for three explicitly named variables
#'              (`var1`, `var2`, `var3`). Creates a grouped bar chart of means by
#'              gender, with error bars.
#'
#' @param data A data frame. Must include `geslacht` and `var1`, `var2`, `var3`.
#' @param var1 The first variable name (unquoted).
#' @param var2 The second variable name (unquoted).
#' @param var3 The third variable name (unquoted).
#' @param thevarlabs A character vector of three labels for `var1`, `var2`, `var3`.
#' @param thelabel A character string for the y-axis label.
#'                 Defaults to "<- 1: never     -     7: very often ->".
#'
#' @details Steps:
#'          1. Maps `var1`, `var2`, `var3` to `thevarlabs`.
#'          2. Converts `geslacht` to labels. Selects `var1`, `var2`, `var3`, `geslacht`, removes NAs.
#'             (Commented code for gender label transformation and reordering).
#'          3. Calculates mean, SE, N for each of the three vars, grouped by `geslacht`.
#'          4. Joins labels, orders vars by global `theorder`.
#'          5. Generates `highcharter` grouped column chart (means per gender) with error bars.
#'             Y-axis 1-7. Legend for gender. Caption with N.
#'
#' @return A `highchart` object.
#'
#' @examples
#' # `theorder` should exist.
#' # by_gender2(survey_data, q1, q2, q3, c("LQ1", "LQ2", "LQ3"))
#'
#' Dependencies: dplyr, tidyr, highcharter, forcats, sjmisc
#'               (Note: `std.error` defined elsewhere; `theorder` global variable)
by_gender2 <- function(data, var1, var2, var3, thevarlabs, thelabel = "<- 1: never     -     7: very often ->") {

  # Create a tibble mapping the three variable names (keys) to provided variable labels.
  varlabdat <- data %>%
    select(var1, var2, var3) %>% # Select the three specific variables
    names() %>%                 # Get their names
    tibble(key = ., varlabs = thevarlabs) # Create a two-column tibble

  # Prepare the final dataset for plotting.
  fin <- data %>%
    # Convert the 'geslacht' (gender) column from coded values to labels.
    mutate(geslacht = sjmisc::to_label(geslacht)) %>%
    # Select the three specified variables and the 'geslacht' column.
    select(var1, var2, var3, geslacht) %>%
    drop_na() #%>% # Remove rows with NA values.
  # Commented out section for transforming gender labels and reordering.
  # mutate(geslacht = case_when(
  #    geslacht == "Vrouw" ~ "Woman",
  #    geslacht == "Anders" ~ "Other",
  #    T ~ geslacht
  # )) %>%
  # mutate(geslacht = fct_relevel(geslacht, c("Man", "Woman", "Other"))) %>%
  # arrange(geslacht)

  # Calculate summary statistics for each variable, grouped by geslacht.
  media_rec_genders <- fin %>%
    drop_na() %>% # Additional NA removal, potentially redundant.
    # Transform data from wide to long format, keeping 'geslacht' separate.
    gather(key, value, -geslacht) %>%
    # Group by variable key and geslacht.
    group_by(key, geslacht) %>%
    # Calculate mean, standard error, and count for each group.
    summarize(mean_val = mean(value, na.rm =T),
              sd_val = std.error(value), # Standard error
              n = n()) %>%
    # Ungroup the data.
    ungroup() %>%
    # Join with the variable labels.
    left_join(varlabdat) %>%
    # Convert 'varlabs' to a factor, ordered by global 'theorder'.
    mutate(varlabs = factor(varlabs, levels = as.character(theorder))) %>%
    # Arrange by 'varlabs'.
    arrange(varlabs)

  # Create a highcharter grouped column chart.
  # `id` assumes up to 3 gender categories for linking error bars.
  hchart(
    media_rec_genders,
    "column",
    # hcaes(x = varlabs, y = mean_val), # For non-grouped chart
    hcaes(x = varlabs, y = mean_val, group = geslacht), # Group columns by 'geslacht'
    id = c("a", "b", "c") # IDs for series, assumes 3 gender groups for linking.
  ) %>%

    # Add error bars series to the chart.
    hc_add_series(
      media_rec_genders,
      "errorbar",
      hcaes(y = mean_val,
            x = varlabs, low = mean_val - sd_val,    # Lower bound of error bar
            high = mean_val + sd_val,   # Upper bound of error bar
            group = geslacht),        # Group error bars by gender
      # The commented out hcaes is an alternative specification.
      # hcaes(y = mean_val, x = key, low = mean_val - sd_val, high = mean_val + sd_val, group = Type),
      # Link error bars to the corresponding column series.
      linkedTo = c("a", "b", "c"),
      enableMouseTracking = TRUE, # Enable tooltips for error bars
      showInLegend = FALSE        # Do not show error bars in the legend
    ) %>%
    # Configure plot options.
    highcharter::hc_plotOptions(
      series = list(
        # Customize tooltip format.
        tooltip = list(pointFormat = '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.2f}</b><br/>')
      ),
      errorbar = list(
        color = "black",      # Color of the error bars
        # whiskerLength = 1, # Option for whisker length
        stemWidth = 1         # Width of the stem of the error bars
      )
    ) %>%
    # Set x-axis options.
    highcharter::hc_xAxis(title = list(text = "")) %>% # No title for x-axis
    # Set y-axis options.
    hc_yAxis(
      title = list(text = thelabel), # Y-axis title
      max = 7, min = 1               # Y-axis limits
    ) %>%
    # Configure the legend.
    hc_legend(
      layout = "vertical",
      align = "right",
      verticalAlign = "top",
      floating = TRUE,
      y = 6
    ) %>%
    # Add a caption to the chart.
    hc_caption(
      text = paste0("<em>N = ", nrow(fin), ". Foutbalken tonen standaardfouten.</em>"), # Caption text
      align = "right",
      style = list(fontSize = '10px', color = 'lightgrey')
    )

}


# --------------------------------------------------------------------------
# Function: by_edu2
# --------------------------------------------------------------------------
#' @title Generate Bar Chart of Means for Three Specific Variables by Education Level
#' @description Similar to `by_edu`, but for three explicitly named variables
#'              (`var1`, `var2`, `var3`). Creates a grouped bar chart of means by
#'              education level (`oplcat`), with error bars.
#'
#' @param data A data frame. Must include `oplcat` and `var1`, `var2`, `var3`.
#' @param var1 The first variable name (unquoted).
#' @param var2 The second variable name (unquoted).
#' @param var3 The third variable name (unquoted).
#' @param thevarlabs A character vector of three labels for `var1`, `var2`, `var3`.
#' @param thelabel A character string for the y-axis label.
#'                 Defaults to "<- 1: never     -     7: very often ->".
#'
#' @details Steps:
#'          1. Maps `var1`, `var2`, `var3` to `thevarlabs`.
#'          2. Processes `oplcat` (NA removal, label conversion). Selects vars, `oplcat`, removes NAs.
#'             (Commented code for education level renaming/reordering).
#'          3. Calculates mean, SE, N for each of the three vars, grouped by `oplcat`.
#'          4. Joins labels, orders vars by global `theorder`.
#'          5. Generates `highcharter` grouped column chart (means per education level) with error bars.
#'             Y-axis 1-7. Legend for education. Caption with N.
#'
#' @return A `highchart` object.
#'
#' @examples
#' # `theorder` should exist.
#' # by_edu2(survey_data, q1, q2, q3, c("LQ1", "LQ2", "LQ3"))
#'
#' Dependencies: dplyr, tidyr, highcharter, forcats, sjmisc
#'               (Note: `std.error` defined elsewhere; `theorder` global variable)
by_edu2 <- function(data, var1, var2, var3, thevarlabs, thelabel = "<- 1: never     -     7: very often ->") {

  # Create a tibble mapping the three variable names (keys) to provided variable labels.
  varlabdat <- data %>%
    select(var1, var2, var3) %>% # Select the three specific variables
    names() %>%                 # Get their names
    tibble(key = ., varlabs = thevarlabs) # Create a two-column tibble

  # Commented out section defining 'education_levels', for alternative label handling.
  # education_levels <- c("Primary (basisonderwijs)",
  #                       "Pre-Vocational (vmbo)",
  #                       "Secondary (havo/vwo)",
  #                       "Vocational (mbo)",
  #                       "Applied Sciences (hbo)",
  #                       "University (wo)") %>%
  #   tibble(eng = ., oplcat = c("basisonderwijs",
  #                              "vmbo",
  #                              "havo/vwo",
  #                              "mbo",
  #                              "hbo",
  #                              "wo"))


  # Prepare the final dataset for plotting.
  fin <- data %>%
    drop_na(oplcat) %>% # Remove rows where 'oplcat' is NA.
    # count(oplcat) %>% # Commented out: count occurrences.
    # Convert 'oplcat' to labels.
    mutate(oplcat = sjmisc::to_label(oplcat)) %>%
    # left_join(education_levels) %>% # Commented out: join with predefined labels.
    # mutate(oplcat = eng) %>% # Commented out: use English labels.
    # Commented out: Relevel 'oplcat' factor for specific ordering.
    # mutate(oplcat = fct_relevel(oplcat, c("Primary (basisonderwijs)",
    #                                      "Pre-Vocational (vmbo)",
    #                                      "Secondary (havo/vwo)",
    #                                      "Vocational (mbo)",
    #                                      "Applied Sciences (hbo)",
    #                                      "University (wo)"))) %>%
    # Select the three specified variables and 'oplcat'.
    select(var1, var2, var3, oplcat) %>%
    drop_na() # Remove rows with any NAs in selected columns.

  # Calculate summary statistics for each variable, grouped by oplcat.
  media_rec_edu <- fin %>%
    # Transform data from wide to long format, keeping 'oplcat' separate.
    gather(key, value, -oplcat) %>%
    # Group by variable key and oplcat.
    group_by(key, oplcat) %>%
    # Calculate mean, standard error, and count for each group.
    summarize(mean_val = mean(value, na.rm =T),
              sd_val = std.error(value), # Standard error
              n = n()) %>%
    # Ungroup the data.
    ungroup() %>%
    # Join with the variable labels.
    left_join(varlabdat) %>%
    # Convert 'varlabs' to a factor, ordered by global 'theorder'.
    mutate(varlabs = factor(varlabs, levels = as.character(theorder))) %>%
    # Arrange by 'varlabs'.
    arrange(varlabs)
  # mutate(varlabs = var_labels) # Commented out alternative labeling.

  # Create a highcharter grouped column chart.
  # `id` assumes up to 6 education categories for linking error bars.
  hchart(
    media_rec_edu,
    "column",
    # hcaes(x = varlabs, y = mean_val), # For non-grouped chart
    hcaes(x = varlabs, y = mean_val, group = oplcat), # Group columns by 'oplcat'
    id = c("a", "b", "c", "d", "e", "f") # IDs for series, assumes 6 edu groups for linking.
  ) %>%

    # Add error bars series to the chart.
    hc_add_series(
      media_rec_edu,
      "errorbar",
      hcaes(y = mean_val,
            x = varlabs, low = mean_val - sd_val,    # Lower bound
            high = mean_val + sd_val,   # Upper bound
            group = oplcat),        # Group error bars by education
      # The commented out hcaes is an alternative specification.
      # hcaes(y = mean_val, x = key, low = mean_val - sd_val, high = mean_val + sd_val, group = Type),
      # Link error bars to column series.
      linkedTo = c("a", "b", "c", "d", "e", "f"),
      enableMouseTracking = TRUE, # Enable tooltips
      showInLegend = FALSE        # Hide error bars from legend
    ) %>%
    # Configure plot options.
    highcharter::hc_plotOptions(
      series = list(
        # Customize tooltip format.
        tooltip = list(pointFormat = '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.2f}</b><br/>')
      ),
      errorbar = list(
        color = "black",      # Error bar color
        # whiskerLength = 1, # Option for whisker length
        stemWidth = 1         # Error bar stem width
      )
    ) %>%
    # Set x-axis options.
    highcharter::hc_xAxis(title = list(text = "")) %>% # No x-axis title
    # Set y-axis options.
    hc_yAxis(
      title = list(text = thelabel), # Y-axis title
      max = 7, min = 1               # Y-axis limits
    ) %>%
    # Configure the legend.
    hc_legend(
      layout = "vertical",
      align = "right",
      verticalAlign = "top",
      floating = TRUE,
      y = 6
    ) %>%
    # Add a caption to the chart.
    hc_caption(
      text = paste0("<em>N = ", nrow(fin), ". Foutbalken tonen standaardfouten.</em>"), # Caption text
      align = "right",
      style = list(fontSize = '10px', color = 'lightgrey')
    )
}


# --------------------------------------------------------------------------
# Function: by_pol2
# --------------------------------------------------------------------------
#' @title Generate Bar Chart of Means for Three Specific Variables by Political Category
#' @description Similar to `by_pol`, but for three explicitly named variables
#'              (`var1`, `var2`, `var3`). Creates a grouped bar chart of means by
#'              political category (`pol_cat`), with error bars.
#'
#' @param data A data frame. Must include `pol_cat` and `var1`, `var2`, `var3`.
#' @param var1 The first variable name (unquoted).
#' @param var2 The second variable name (unquoted).
#' @param var3 The third variable name (unquoted).
#' @param thevarlabs A character vector of three labels for `var1`, `var2`, `var3`.
#' @param thelabel A character string for the y-axis label.
#'                 Defaults to "<- 1: never     -     7: very often ->".
#'
#' @details Steps:
#'          1. Maps `var1`, `var2`, `var3` to `thevarlabs`.
#'          2. Converts `pol_cat` to labels. Selects vars, `pol_cat`, removes NAs.
#'          3. Calculates mean, SE, N for each of the three vars, grouped by `pol_cat`.
#'          4. Joins labels, orders vars by global `theorder`, relevels `pol_cat`.
#'          5. Generates `highcharter` grouped column chart (means per political category) with error bars.
#'             Y-axis 1-7. Legend for political categories. Caption with N and `pol_cat` definition.
#'
#' @return A `highchart` object.
#'
#' @examples
#' # `theorder` should exist.
#' # by_pol2(survey_data, q1, q2, q3, c("LQ1", "LQ2", "LQ3"))
#'
#' Dependencies: dplyr, tidyr, highcharter, forcats, sjmisc
#'               (Note: `std.error` defined elsewhere; `theorder` global variable)
by_pol2 <- function(data, var1, var2, var3, thevarlabs, thelabel = "<- 1: never     -     7: very often ->") {

  # Create a tibble mapping the three variable names (keys) to provided variable labels.
  varlabdat <- data %>%
    select(var1, var2, var3) %>% # Select the three specific variables
    names() %>%                 # Get their names
    tibble(key = ., varlabs = thevarlabs) # Create a two-column tibble

  # Prepare the final dataset for plotting.
  fin <- data %>%
    # Convert 'pol_cat' to labels. Typo `oplcat` corrected to `pol_cat` based on context.
    mutate(pol_cat = sjmisc::to_label(pol_cat)) %>% # Corrected oplcat to pol_cat
    # Select the three specified variables and 'pol_cat'.
    select(var1, var2, var3, pol_cat) %>%
    drop_na() # Remove rows with any NAs.

  # Calculate summary statistics for each variable, grouped by pol_cat.
  media_rec_pol <- fin %>%
    # Transform data from wide to long format, keeping 'pol_cat' separate.
    gather(key, value, -pol_cat) %>%
    # Group by variable key and pol_cat.
    group_by(key, pol_cat) %>%
    # Calculate mean, standard error, and count for each group.
    summarize(mean_val = mean(value, na.rm =T),
              sd_val = std.error(value), # Standard error
              n = n()) %>%
    # Ungroup the data.
    ungroup() %>%
    # Join with the variable labels.
    left_join(varlabdat) %>%
    # Convert 'varlabs' to a factor, ordered by global 'theorder'.
    mutate(varlabs = factor(varlabs, levels = as.character(theorder))) %>%
    # Arrange by 'varlabs'.
    arrange(varlabs) %>%
    # Relevel 'pol_cat' factor for specific ordering.
    mutate(pol_cat = fct_relevel(pol_cat, c("left", "center", "right")))
  # mutate(varlabs = var_labels) # Commented out alternative labeling.

  # Create a highcharter grouped column chart.
  # `id` assumes up to 3 political categories for linking error bars.
  hchart(
    media_rec_pol,
    "column",
    # hcaes(x = varlabs, y = mean_val), # For non-grouped chart
    hcaes(x = varlabs, y = mean_val, group = pol_cat), # Group columns by 'pol_cat'
    id = c("a", "b", "c") # IDs for series, assumes 3 pol_cat groups for linking.
  ) %>%

    # Add error bars series to the chart.
    hc_add_series(
      media_rec_pol,
      "errorbar",
      hcaes(y = mean_val,
            x = varlabs, low = mean_val - sd_val,    # Lower bound
            high = mean_val + sd_val,   # Upper bound
            group = pol_cat),        # Group error bars by political category
      # The commented out hcaes is an alternative specification.
      # hcaes(y = mean_val, x = key, low = mean_val - sd_val, high = mean_val + sd_val, group = Type),
      # Link error bars to column series.
      linkedTo = c("a", "b", "c"),
      enableMouseTracking = TRUE, # Enable tooltips
      showInLegend = FALSE        # Hide error bars from legend
    ) %>%
    # Configure plot options.
    highcharter::hc_plotOptions(
      series = list(
        # Customize tooltip format.
        tooltip = list(pointFormat = '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.2f}</b><br/>')
      ),
      errorbar = list(
        color = "black",      # Error bar color
        # whiskerLength = 1, # Option for whisker length
        stemWidth = 1         # Error bar stem width
      )
    ) %>%
    # Set x-axis options.
    highcharter::hc_xAxis(title = list(text = "")) %>% # No x-axis title
    # Set y-axis options.
    hc_yAxis(
      title = list(text = thelabel), # Y-axis title
      max = 7, min = 1               # Y-axis limits
    ) %>%
    # Configure the legend.
    hc_legend(
      layout = "vertical",
      align = "right",
      verticalAlign = "top",
      floating = TRUE,
      y = 6
    ) %>%
    # Add a caption to the chart.
    hc_caption(
      text = paste0("<em>N = ", nrow(fin), ". Foutbalken tonen standaardfouten. Politics category is based on 10-scale: 0-3: left; 4-6: center; 7-10: right.</em>"), # Caption text
      align = "right",
      style = list(fontSize = '10px', color = 'lightgrey')
    )
}

# --------------------------------------------------------------------------
# Function: plot_to_html
# --------------------------------------------------------------------------
#' @title Convert a Plot Object to HTML
#' @description This function takes a plot object (presumably a `highcharter` or
#'              `htmlwidget` object) and wraps it in HTML `div` tags. It is
#'              intended for embedding plots in HTML documents, such as those
#'              generated by Quarto or R Markdown.
#'
#' @param plot A plot object that can be rendered as HTML (e.g., `highchart` object).
#'
#' @details If the input `plot` is NULL, it prints a message to the console and
#'          returns the string "NULL plot". Otherwise, it converts the plot to an
#'          HTML tag list using `htmltools::tagList` and then wraps this in a
#'          `div` with class "flex-item2". The result is returned as a character string.
#'
#' @return A character string containing the HTML representation of the plot,
#'         or "NULL plot" if the input was NULL.
#'
#' @examples
#' # Assuming 'my_hc_plot' is a highchart object:
#' # html_code <- plot_to_html(my_hc_plot)
#' # cat(html_code)
#'
#' # Handling a NULL plot:
#' # plot_to_html(NULL)
#'
#' Dependencies: htmltools, shiny (tags$div)
plot_to_html <- function(plot) {
  # Check if the plot object is NULL.
  if (is.null(plot)) {
    # If NULL, print a message to the console.
    cat("NULL plot detected!\n")
    # Return a specific string indicating a NULL plot.
    return("NULL plot")
  }
  # If the plot is not NULL, convert it to an HTML structure.
  # `tags$div` creates a <div> HTML element.
  # `class = "flex-item2"` assigns a CSS class to the div.
  # `htmltools::tagList(plot)` converts the plot object into an HTML tag list,
  # which is then embedded within the div.
  # The entire structure is converted to a character string.
  as.character(tags$div(
    class = "flex-item2",
    htmltools::tagList(plot)
  ))
}


# --------------------------------------------------------------------------
# Function: generate_quarto_elements
# --------------------------------------------------------------------------
#' @title Generate Quarto Output for a List of Plots
#' @description This function takes a list of plot objects and generates Quarto/Markdown
#'              output to display them. Currently, it iterates through the plots
#'              and prints each one under a '### Page X' heading.
#'              The commented-out section suggests a previous implementation aimed at
#'              arranging plots in a table with a fixed number of plots per page/row.
#'
#' @param list_of_plots A list where each element is a plot object (e.g., `highchart`).
#' @param plots_per_page An integer specifying how many plots should ideally be
#'                       grouped per "page" or section. This parameter is used to
#'                       calculate `num_pages` but is not directly used in the active
#'                       code's plotting logic (which plots one per "page").
#'                       Defaults to 2.
#'
#' @details The function first calculates the total number of plots and the potential
#'          number of "pages" based on `plots_per_page`. These are stored in global
#'          variables `num_plots` and `num_pages`.
#'          The active part of the function then iterates through `list_of_plots` using `purrr::walk`.
#'          For each plot:
#'          1. A counter `page` (global) is incremented.
#'          2. A Markdown heading "### `page`" is printed to the console using `cat`.
#'          3. The plot is converted to HTML using `plot_to_html` and then printed using `cat`.
#'          This will directly output the Markdown/HTML to be rendered by Quarto.
#'
#'          The commented-out code block shows an attempt to create an HTML table
#'          to arrange plots side-by-side, which is currently not active.
#'
#' @return This function does not return a value explicitly but prints Markdown/HTML
#'         to the console via `cat`, intended for inclusion in a Quarto document.
#'
#' @examples
#' # Assuming plot1, plot2, plot3 are highchart objects:
#' # my_plots <- list(plot1, plot2, plot3)
#' # generate_quarto_elements(my_plots) # Will print Quarto content for each plot
#'
#' Dependencies: purrr, htmltools (via plot_to_html), shiny (via plot_to_html)
#'               (Note: Uses global assignment `<<-` for `num_plots`, `num_pages`, and `page`)
generate_quarto_elements <- function(list_of_plots, plots_per_page = 2) {

  # Calculate the total number of plots and store it in a global variable `num_plots`.
  num_plots <<- length(list_of_plots)
  # Calculate the number of pages needed based on `plots_per_page` and store globally.
  num_pages <<- ceiling(num_plots / plots_per_page)

  # Commented-out section: Alternative implementation for arranging plots in a table.
  # This loop would iterate through pages and create an HTML table for plots on each page.
  # for (page in 1:num_pages) {
  #    start_index <- (page - 1) * plots_per_page + 1
  #    end_index <- min(page * plots_per_page, num_plots)
  #
  #    plots_for_page <- list_of_plots[start_index:end_index]
  #
  #    html_content <<- paste( # Assigns to global `html_content`
  #      '<table style="width:100%; border-spacing: 1px;">',
  #      '<tr>',
  #      paste(
  #        lapply(plots_for_page, function(plot) {
  #          plot_html <- plot_to_html(plot)
  #          if (str_detect(plot_html, "NULL")) { # Requires stringr::str_detect
  #            cat("NULL detected in plot HTML!\n")
  #          }
  #          paste0('<td style="width:50%; vertical-align: top;">', plot_html, '</td>')
  #        }),
  #        collapse = "\n"
  #      ),
  #      '</tr>',
  #      '</table>'
  #    )
  #
  #    istherenull2 <<- str_detect(html_content, "NULL") # Global assignment, requires stringr
  #
  #    if(!is.null(html_content)){
  #      cat(paste0("### ", page, "\n")) # Prints a Markdown heading
  #      cat(html_content) # Prints the HTML table content
  #    }
  # }

  # Initialize a global page counter.
  page <- 0
  # Iterate through each plot in the `list_of_plots`.
  list_of_plots %>%
    walk(~{ # `walk` is used for side effects (like printing) for each element.
      # Increment the global page counter.
      page <<- page + 1
      # if(!is.null(html_content)){ # This condition seems to be a remnant from the commented block.
      # Print a Markdown level 3 heading with the current page number.
      cat(paste0("### ", page, "\n"))
      # Convert the current plot to HTML using `plot_to_html` and print it.
      cat(plot_to_html(.x))
      # }
    })

}

# --------------------------------------------------------------------------
# Function: viz_general
# --------------------------------------------------------------------------
#' @title Generate General Visualization (Stacked Bar Chart)
#' @description This function creates a stacked bar chart showing the distribution
#'              of responses for a set of variables. Responses are typically
#'              categorized (e.g., into low, medium, high based on a Likert scale).
#'              The function can operate in two modes: general summary or grouped summary.
#'
#' @param vars A character vector of variable names to include in the visualization.
#' @param var_labels A character vector of labels corresponding to `vars`.
#' @param categories_dat A character vector of 3 category labels (e.g., c("High", "Medium", "Low")).
#'                       The recoding logic assumes a 1-7 scale: 5-7 maps to `categories_dat[1]`,
#'                       4 maps to `categories_dat[2]`, and 1-3 maps to `categories_dat[3]`.
#' @param grpvar An optional character string specifying the name of a grouping variable
#'               in `data`. If `NULL` (default), a general summary is produced.
#'               If provided, `groups` should be `TRUE`.
#' @param groups A logical flag. If `FALSE` (default), a single stacked bar chart for all
#'               variables is generated. If `TRUE`, separate stacked bar charts are generated
#'               for each variable, grouped by `grpvar`.
#'
#' @details
#' **Common Steps:**
#'   - The input `data` is assumed to be globally available.
#'   - Values for selected variables are recoded into three categories based on `categories_dat`.
#'   - Percentages for each category within each variable (and group, if `groups = TRUE`) are calculated.
#'
#' **If `groups = FALSE`:**
#'   1. Selects `vars` from `data`, renames them with `var_labels`.
#'   2. Calculates percentages for the three categories for each variable.
#'   3. Determines an order (`theorder`, global) for variables based on the percentage of the
#'      third category (`categories_dat[3]`) in descending order.
#'   4. Generates a single stacked bar chart using `highcharter` where:
#'      - X-axis shows variables (ordered by `theorder`).
#'      - Y-axis shows percentage (0-100%).
#'      - Bars are stacked by the three categories.
#'      - Data labels show percentages if > 5%.
#'      - Legend order is explicitly set for categories.
#'      - Caption shows N. Export options are enabled.
#'   5. Returns the `highchart` object.
#'
#' **If `groups = TRUE`:**
#'   1. Creates a mapping `varlabdat` (variable names to labels).
#'   2. Selects `vars` and `grpvar` from `data`. Renames `vars` using `thevarlabs` (which seems
#'      to be a typo and should likely be `var_labels`). The grouping variable is named `thevar`.
#'   3. Calculates percentages for the three categories for each variable, further grouped by `thevar`.
#'   4. Uses the globally existing `theorder` (presumably set by a non-grouped call or another function).
#'   5. For each variable in `theorder` (taken from levels of `key` after ordering):
#'      - Filters data for that specific variable.
#'      - Creates a stacked bar chart where:
#'         - X-axis shows levels of `grpvar` (`thevar`).
#'         - Y-axis shows percentage.
#'         - Bars stacked by categories.
#'         - Chart title is the variable label.
#'         - Similar styling (data labels, legend, caption, export) as the non-grouped version.
#'      - The legend order for categories is adjusted for each plot.
#'   6. The list of generated `highchart` objects (`hc`) is then passed to
#'      `generate_quarto_elements` to print them sequentially in a Quarto document.
#'
#' @return If `groups = FALSE`, returns a single `highchart` object.
#'         If `groups = TRUE`, the function calls `generate_quarto_elements` which prints
#'         HTML/Markdown to the console and does not return a plot object directly from `viz_general`.
#'
#' @examples
#' # Assumes 'data' is in the global environment.
#' # 'colors' and 'myMenuItems' are assumed to be globally defined for highcharter styling.
#' # General summary:
#' # viz_general(vars = c("q1", "q2"),
#' #             var_labels = c("Question 1", "Question 2"),
#' #             categories_dat = c("Agree", "Neutral", "Disagree"))
#'
#' # Grouped summary:
#' # `theorder` should exist if a specific order is desired for grouped plots.
#' # data$age_category <- sample(c("Young", "Mid", "Old"), nrow(data), replace = TRUE)
#' # viz_general(vars = c("q1", "q2"),
#' #             var_labels = c("Question 1", "Question 2"),
#' #             categories_dat = c("Positive", "Neutral", "Negative"),
#' #             grpvar = "age_category",
#' #             groups = TRUE)
#'
#' Dependencies: dplyr, tidyr, highcharter, forcats, purrr, sjmisc (implicitly if grpvar needs to_label)
#'               (Note: Assumes `data`, `colors`, `myMenuItems` are globally available.
#'               Uses global assignment `<<-` for `theorder` and within `generate_quarto_elements`.
#'               The `std.error` function is not directly used here but might be part of the environment.)
viz_general <- function(vars, var_labels, categories_dat, grpvar = NULL, groups = F) {
  # Check if the analysis should be grouped.
  if(groups){
    # ---- Grouped Analysis ----

    # Create a mapping of original variable names to their labels.
    varlabdat <- data %>%
      select(all_of(vars)) %>% # Select specified variables using all_of for safety.
      names() %>%
      tibble(key = ., varlabs = var_labels)

    # Prepare data for grouped analysis.
    fin <- data %>%
      # Select specified variables, any column containing "thevar" (potentially problematic if unintended),
      # and the grouping variable (renamed to 'thevar').
      select(all_of(vars), contains("thevar"), thevar = all_of(grpvar)) %>%
      drop_na() %>%
      # Set names: first set of names from 'thevarlabs' (potential typo, likely meant 'var_labels'),
      # and the last one to "thevar". This renaming is fragile if `contains("thevar")` matches more than expected.
      # It assumes 'thevarlabs' (or var_labels) has the same length as 'vars'.
      set_names(c(var_labels, "thevar")) # Corrected to var_labels, assuming one grpvar. Careful if contains("thevar") selects more.

    # Process data to calculate percentages for categories within each group.
    media_rec_ages <- fin %>%
      gather(key, value,-thevar) %>% # Pivot longer, excluding the grouping variable 'thevar'.
      mutate(
        # Recode 'value' into three categories based on predefined numeric ranges.
        # categories_dat[3] for values 1-3 (e.g., Low/Disagree)
        # categories_dat[2] for value 4 (e.g., Neutral)
        # categories_dat[1] for values 5-7 (e.g., High/Agree)
        value = case_when(
          value %in% 1:3 ~ categories_dat[3],
          value == 4 ~ categories_dat[2],
          value %in% 5:7 ~ categories_dat[1]
        )
      ) %>%
      count(key, thevar, value) %>% # Count occurrences of each category per variable and group.
      group_by(key, thevar) %>%     # Group by variable (key) and the grouping variable (thevar).
      mutate(perc = n / sum(n) * 100) %>% # Calculate percentage for each category.
      ungroup()
  } else {
    # ---- Non-Grouped (General) Analysis ----

    # Prepare data for general analysis.
    fin <- data %>%
      select(all_of(vars)) %>% # Select specified variables.
      drop_na() %>%
      set_names(var_labels) # Rename columns with provided labels.

    # Process data to calculate percentages for categories for each variable.
    media_rec <- fin %>%
      gather(key, value) %>% # Pivot longer.
      mutate(value = case_when( # Recode 'value' into categories.
        value %in% 1:3 ~ categories_dat[3],
        value == 4 ~ categories_dat[2],
        value %in% 5:7 ~ categories_dat[1]
      )) %>%
      group_by(key) %>% # Group by variable (key).
      count(value) %>%  # Count occurrences of each category per variable.
      ungroup()  %>%
      # Relevel categories to ensure desired order in plot legend/stacking.
      mutate(value = fct_relevel(value, categories_dat)) %>%
      group_by(key) %>%
      mutate(perc = n/sum(n)*100) %>% # Calculate percentage.
      ungroup()

    # Determine the order of variables for the plot.
    # Variables are ordered by the descending percentage of the third category (e.g., "Low" or "Disagree").
    theorder <<- media_rec %>%
      filter(value == categories_dat[3]) %>%
      arrange(desc(perc)) %>%
      pull(key)
  }

  # Generate plot(s).
  if(groups){
    # For grouped analysis, generate a plot for each variable.
    # `hc` will be a list of highchart objects.
    hc <<- media_rec_ages %>% # Using media_rec_ages prepared in the `groups = TRUE` block.
      # Relevel 'key' (variables) based on 'theorder' (assumed to exist globally or set by non-grouped part).
      # This part implies `theorder` should be established before calling with `groups = TRUE`
      # if a consistent cross-variable order is desired. If `theorder` isn't set, factor levels might be alphabetical/appearance.
      mutate(key = fct_relevel(key, as.character(theorder))) %>%
      arrange(key) %>% # Arrange by the factor levels of key.
      pull(key) %>%    # Get unique, ordered variable keys.
      levels() %>%     # Get factor levels (maintains order).
      map(~{ # Iterate over each variable key.
        # Current variable being processed is .x
        hc_plot <- media_rec_ages %>%
          filter(key == .x) %>% # Filter data for the current variable.
          # Relevel 'value' (categories) for consistent legend order.
          mutate(value = fct_relevel(value, categories_dat)) %>%
          # Create a stacked bar chart.
          hchart("bar", hcaes(x = thevar, y = perc, group = value)) %>%
          hc_title(text = .x) %>% # Set chart title to the current variable label.
          hc_chart(style = list(width = "100%", height = "100%"))  %>% # Chart styling.
          hc_plotOptions(bar = list(stacking = "percent")) %>% # Enable percent stacking.
          hc_yAxis(title = list(text = ""), max = 100) %>% # Y-axis options (percentage).
          hc_colors(colors) %>% # Apply predefined colors (assumes 'colors' is globally defined).
          hc_xAxis(title = list(text = "")) %>% # No X-axis title.
          hc_legend(enabled = TRUE) %>% # Enable legend.
          hc_plotOptions(
            column = list( # Although it's a "bar" chart, column options might affect some aspects or be a general container.
              colorByPoint = TRUE # Colors each point if not grouped by series (less relevant for stacked).
            ),
            series = list(
              # Tooltip customization.
              tooltip = list(pointFormat = '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.2f}%</b><br/>'),
              # Data labels on bars.
              dataLabels = list(
                enabled = TRUE,
                format = '{y:.0f}%', # Format as integer percentage.
                color = 'white',
                style = list(
                  fontSize = '10px',
                  fontWeight = 'bold'
                ),
                inside = TRUE, # Place label inside the bar.
                verticalAlign = 'middle',
                align = 'center',
                filter = list( # Show label only if y value > 5.
                  property = 'y',
                  operator = '>',
                  value = 5
                )
              )
            )
          ) %>%
          hc_caption( # Add caption with sample size.
            text = paste0("<em>N = ", nrow(fin), ".</em>"), # nrow(fin) might be for the whole group subset, not per plot.
            align = "right",
            style = list(fontSize = '10px', color = 'lightgrey')
          ) %>%
          hc_exporting( # Enable chart exporting options.
            enabled = TRUE,
            # `myMenuItems` should be a globally defined list for custom export items.
            buttons = list(contextButton = list(menuItems = myMenuItems))
          )

        # Explicitly set legendIndex for series to control legend order.
        hc_plot$x$hc_opts$series <- lapply(hc_plot$x$hc_opts$series, function(series) {
          if (series$name == categories_dat[3]) {
            series$legendIndex <- 0
          } else if (series$name == categories_dat[2]) {
            series$legendIndex <- 1
          } else if (series$name == categories_dat[1]) {
            series$legendIndex <- 2
          }
          return(series)
        })

        return(hc_plot) # Return the generated highchart object for this variable.
      })

  } else {
    # For non-grouped analysis, generate a single plot.
    hc <- media_rec %>% # Using media_rec from the `groups = FALSE` block.
      # Relevel 'key' (variables) based on 'theorder' determined earlier.
      mutate(key = fct_relevel(key, as.character(theorder))) %>%
      arrange(key) %>% # Arrange by the factor levels.
      # Create a stacked bar chart.
      hchart("bar", hcaes(x = key, y = perc, group = value))  %>%
      hc_plotOptions(bar = list(stacking = "percent")) %>% # Enable percent stacking.
      hc_yAxis(title = list(text = ""), max = 100) %>% # Y-axis options.
      hc_colors(colors) %>% # Apply predefined global 'colors'.
      hc_xAxis(title = list(text = "")) %>% # No X-axis title.
      hc_legend(enabled = TRUE) %>% # Enable legend.
      hc_plotOptions(
        column = list(
          colorByPoint = TRUE
        ),
        series = list(
          # Tooltip customization.
          tooltip = list(pointFormat = '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.2f}%</b><br/>'),
          # Data labels on bars.
          dataLabels = list(
            enabled = TRUE,
            format = '{y:.0f}%',
            color = 'white',
            style = list(
              fontSize = '12px', # Slightly larger font size than grouped version.
              fontWeight = 'bold'
            ),
            inside = TRUE,
            verticalAlign = 'middle',
            align = 'center',
            filter = list(
              property = 'y',
              operator = '>',
              value = 5
            )
          )
        )
      ) %>%
      hc_caption( # Add caption with sample size.
        text = paste0("<em>N = ", nrow(fin), ".</em>"),
        align = "right",
        style = list(fontSize = '10px', color = 'lightgrey')
      ) %>%
      hc_exporting( # Enable chart exporting.
        enabled = TRUE,
        buttons = list(contextButton = list(menuItems = myMenuItems)) # Global `myMenuItems`.
      )

    # Explicitly set legendIndex for series to control legend order.
    hc$x$hc_opts$series <- lapply(hc$x$hc_opts$series, function(series) {
      if (series$name == categories_dat[3]) {
        series$legendIndex <- 0
      } else if (series$name == categories_dat[2]) {
        series$legendIndex <- 1
      } else if (series$name == categories_dat[1]) {
        series$legendIndex <- 2
      }
      return(series)
    })
  }

  # Output handling.
  if(groups){
    # If grouped, pass the list of plots to `generate_quarto_elements` for rendering.
    # This function prints to console, so `viz_general` itself won't return the plots.
    generate_quarto_elements(hc, plots_per_page = 2)
  } else {
    # If not grouped, return the single highchart object.
    return(hc)
  }


}


viz_wave_change <- function(vars, var_labels, categories_dat, wavevar,
                            range1 = 1:2, range2 = 3, range3 = 4:5,
                            weight_var = NULL) {

  # Prepare data
  fin <- data %>%
    select(all_of(vars), wave = !!sym(wavevar), weight = !!sym(weight_var)) %>%
    drop_na() %>%
    set_names(c(var_labels, "wave", "weight"))

  media_wave <- fin %>%
    pivot_longer(cols = all_of(var_labels), names_to = "key", values_to = "value") %>%
    mutate(
      value = case_when(
        value %in% range1 ~ categories_dat[3],
        value %in% range2 ~ categories_dat[2],
        value %in% range3 ~ categories_dat[1],
        TRUE ~ NA_character_
      ),
      value = fct_relevel(value, categories_dat)
    ) %>%
    drop_na(value) %>%
    count(wave, key, value, wt = weight) %>%
    group_by(wave, key) %>%
    mutate(perc = n / sum(n) * 100) %>%
    ungroup()

  # Order variables by category3 in latest wave
  latest_wave <- max(media_wave$wave)
  theorder <- media_wave %>%
    filter(wave == latest_wave, value == categories_dat[3]) %>%
    arrange(desc(perc)) %>%
    pull(key) %>%
    unique()

  # Plot one line chart per variable (key)
  hcs <- map(theorder, function(varkey) {
    media_wave %>%
      filter(key == varkey) %>%
      hchart("line", hcaes(x = as.character(wave), y = perc, group = value)) %>%
      hc_title(text = varkey) %>%
      hc_colors(colors) %>%
      hc_xAxis(title = list(text = "Wave")) %>%
      hc_yAxis(title = list(text = "Percentage"), max = max(media_wave$perc)+5) %>%
      hc_tooltip(
        shared = TRUE,
        valueDecimals = 1,
        valueSuffix = "%"
      ) %>%
      hc_plotOptions(
        line = list(
          dataLabels = list(
            enabled = TRUE,
            format = '{y:.0f}%',
            style = list(fontSize = '10px')
          ),
          marker = list(enabled = TRUE)
        )
      ) %>%
      hc_legend(enabled = TRUE) %>%
      hc_caption(
        text = paste0("<em>N = ", nrow(fin), ".</em>"),
        align = "right",
        style = list(fontSize = '10px', color = 'lightgrey')
      ) %>%
      hc_exporting(enabled = TRUE, buttons = list(contextButton = list(menuItems = myMenuItems)))
  })

  return(hcs)
}



# --------------------------------------------------------------------------
# Function: viz_wave_change
# --------------------------------------------------------------------------
#' @title Visualize Changes Across Waves for Multiple Variables
#' @description This function generates a series of line charts, one for each specified
#'              variable, showing how the distribution of responses across three
#'              predefined categories changes over different waves (e.g., survey waves).
#'              It supports weighted data.
#'
#' @param vars A character vector of variable names from the global `data` object to be analyzed.
#' @param var_labels A character vector of labels corresponding to the `vars`.
#'                   These labels will be used as chart titles.
#' @param categories_dat A character vector of exactly three category labels.
#'                       The recoded data will be grouped into these three categories.
#'                       Example: `c("Positive", "Neutral", "Negative")`.
#' @param wavevar A character string specifying the name of the column in `data`
#'                that identifies the different waves (e.g., "survey_round").
#' @param range1 A numeric vector defining the raw values to be recoded into `categories_dat[3]` (the third category).
#'               Defaults to `1:2`.
#' @param range2 A numeric vector defining the raw values to be recoded into `categories_dat[2]` (the second category).
#'               Defaults to `3`.
#' @param range3 A numeric vector defining the raw values to be recoded into `categories_dat[1]` (the first category).
#'               Defaults to `4:5`.
#' @param weight_var An optional character string specifying the name of the column in `data`
#'                   to be used for weighting. If `NULL` (default), data will not be weighted.
#'
#' @details
#' The function performs the following main steps:
#' 1.  **Data Preparation**: Selects the specified variables (`vars`), the wave variable (`wavevar`),
#'     and an optional weight variable (`weight_var`) from the global `data` object.
#'     It removes rows with missing values in these selected columns and renames them
#'     using `var_labels` (for variables), "wave", and "weight".
#' 2.  **Data Transformation**:
#'     -   Pivots the data from a wide to a long format.
#'     -   Recodes the values of each variable into three categories based on the `range1`,
#'         `range2`, and `range3` arguments, assigning them labels from `categories_dat`.
#'         The mapping is: `range1` -> `categories_dat[3]`, `range2` -> `categories_dat[2]`,
#'         `range3` -> `categories_dat[1]`.
#'     -   Converts the recoded categories into an ordered factor based on `categories_dat`.
#'     -   Counts the (optionally weighted) occurrences of each category for each variable within each wave.
#'     -   Calculates the percentage of each category within each variable and wave.
#' 3.  **Variable Ordering**: Determines the plotting order of the variables. Variables are
#'     ordered based on the descending percentage of the third category (`categories_dat[3]`)
#'     in the latest available wave.
#' 4.  **Plotting**: For each variable (in the determined order), it generates a line chart
#'     using `highcharter`. Each chart displays:
#'     -   Trends for the three categories over the waves.
#'     -   A title corresponding to the variable label.
#'     -   Custom colors (from a globally defined `colors` object).
#'     -   Configured X and Y axes, tooltips, data labels on lines, legend, and a caption
#'         showing the total number of observations (`N`) after initial NA removal.
#'     -   Exporting options (using a globally defined `myMenuItems` object).
#'
#' @return A list of `highchart` objects. Each element in the list is a line chart
#'         for one of the input variables, showing trends across waves.
#'
#' @examples
#' # Assume 'data' is a data frame in the global environment with columns:
#' # 'q1', 'q2' (numeric, e.g., 1-5 scale)
#' # 'survey_round' (e.g., 1, 2, 3 indicating waves)
#' # 'sample_weights' (optional numeric weights)
#'
#' # Assume 'colors' and 'myMenuItems' are defined globally for highcharter styling.
#' # colors <- c("#007bff", "#28a745", "#dc3545")
#' # myMenuItems <- c("downloadPNG", "downloadJPEG", "downloadSVG")
#'
#' # example_vars <- c("q1", "q2")
#' # example_var_labels <- c("Question 1: Satisfaction", "Question 2: Agreement")
#' # example_categories <- c("High (4-5)", "Mid (3)", "Low (1-2)")
#'
#' # wave_plots <- viz_wave_change(
#' #   vars = example_vars,
#' #   var_labels = example_var_labels,
#' #   categories_dat = example_categories,
#' #   wavevar = "survey_round",
#' #   range1 = 1:2, # Maps to example_categories[3] "Low (1-2)"
#' #   range2 = 3,   # Maps to example_categories[2] "Mid (3)"
#' #   range3 = 4:5, # Maps to example_categories[1] "High (4-5)"
#' #   weight_var = "sample_weights"
#' # )
#'
#' # To display the first plot:
#' # if (length(wave_plots) > 0) {
#' #   wave_plots[[1]]
#' # }
#'
#' Dependencies: dplyr, tidyr, highcharter, forcats, purrr
#'               (Assumes `data`, `colors`, and `myMenuItems` are available in the global environment.)
viz_wave_change <- function(vars, var_labels, categories_dat, wavevar,
                            range1 = 1:2, range2 = 3, range3 = 4:5,
                            weight_var = NULL) {

  # Prepare data
  # Select the specified variables, wave variable, and weight variable (if provided).
  # Uses `!!sym()` to correctly evaluate string inputs for column names with `dplyr`.
  fin <- data %>%
    select(all_of(vars), wave = !!sym(wavevar), weight = !!sym(weight_var)) %>%
    # Remove rows with NA in any of the selected columns.
    drop_na() %>%
    # Rename columns: variables get `var_labels`, wave column becomes "wave", weight column becomes "weight".
    set_names(c(var_labels, "wave", "weight"))

  # Transform data for plotting: calculate percentages for each category by wave and variable.
  media_wave <- fin %>%
    # Pivot data from wide to long format. `var_labels` are now in the 'key' column.
    pivot_longer(cols = all_of(var_labels), names_to = "key", values_to = "value") %>%
    # Recode the 'value' column into the three specified categories.
    mutate(
      value = case_when(
        value %in% range1 ~ categories_dat[3], # Values in range1 map to the 3rd category label
        value %in% range2 ~ categories_dat[2], # Values in range2 map to the 2nd category label
        value %in% range3 ~ categories_dat[1], # Values in range3 map to the 1st category label
        TRUE ~ NA_character_ # Assign NA if value doesn't fall into any range
      ),
      # Convert the 'value' column (categories) to a factor, ordered according to `categories_dat`.
      value = fct_relevel(value, categories_dat)
    ) %>%
    # Remove rows where 'value' became NA after recoding (i.e., original values not in any range).
    drop_na(value) %>%
    # Count observations for each combination of wave, variable (key), and category (value).
    # Apply weights if `weight_var` was specified (wt = weight).
    count(wave, key, value, wt = weight) %>%
    # Group by wave and variable (key) to calculate percentages within these groups.
    group_by(wave, key) %>%
    # Calculate percentage for each category.
    mutate(perc = n / sum(n) * 100) %>%
    # Ungroup for further operations.
    ungroup()

  # Determine the order of variables for plotting.
  # Variables are ordered by the descending percentage of the third category (`categories_dat[3]`)
  # in the latest wave.
  latest_wave <- max(media_wave$wave) # Find the latest wave number.
  theorder <- media_wave %>%
    # Filter data for the latest wave and the third category.
    filter(wave == latest_wave, value == categories_dat[3]) %>%
    # Arrange by percentage in descending order.
    arrange(desc(perc)) %>%
    # Pull the unique variable keys (labels) in the determined order.
    pull(key) %>%
    unique()

  # Generate one line chart per variable (key) using `purrr::map`.
  hcs <- map(theorder, function(varkey) { # `varkey` is the current variable label being processed.
    media_wave %>%
      # Filter the processed data for the current variable.
      filter(key == varkey) %>%
      # Create a line chart with highcharter.
      # X-axis is wave (converted to character for discrete points), Y-axis is percentage,
      # lines are grouped by category ('value').
      hchart("line", hcaes(x = as.character(wave), y = perc, group = value)) %>%
      # Set the chart title to the current variable label (`varkey`).
      hc_title(text = varkey) %>%
      # Apply predefined colors (assumes `colors` is a global vector of color codes).
      hc_colors(colors) %>%
      # Configure X-axis.
      hc_xAxis(title = list(text = "Wave")) %>%
      # Configure Y-axis, setting max slightly above max percentage for better visualization.
      hc_yAxis(title = list(text = "Percentage"), max = max(media_wave$perc, na.rm = TRUE) + 5) %>% # Ensure NA values in perc are handled for max
      # Configure tooltip for shared display, showing percentages with one decimal place.
      hc_tooltip(
        shared = TRUE,
        valueDecimals = 1,
        valueSuffix = "%"
      ) %>%
      # Configure plot options for lines, including data labels and markers.
      hc_plotOptions(
        line = list(
          dataLabels = list(
            enabled = TRUE, # Enable data labels on lines.
            format = '{y:.0f}%', # Format as integer percentage.
            style = list(fontSize = '10px') # Style for data labels.
          ),
          marker = list(enabled = TRUE) # Enable markers on data points.
        )
      ) %>%
      # Enable the legend.
      hc_legend(enabled = TRUE) %>%
      # Add a caption with the total number of initial valid observations (N from `fin`).
      hc_caption(
        text = paste0("<em>N = ", nrow(fin), ".</em>"),
        align = "right",
        style = list(fontSize = '10px', color = 'lightgrey')
      ) %>%
      # Enable exporting options (assumes `myMenuItems` is a global list for export buttons).
      hc_exporting(enabled = TRUE, buttons = list(contextButton = list(menuItems = myMenuItems)))
  })

  # Return the list of generated highchart objects.
  return(hcs)
}

# --------------------------------------------------------------------------
# Function: vecc
# --------------------------------------------------------------------------
#' @title Create a Concatenated String
#' @description This is a simple utility function that concatenates a name (string)
#'              and a number.
#'
#' @param name A character string.
#' @param num A number (will be coerced to character by `paste0`).
#'
#' @return A character string which is the concatenation of `name` and `num`.
#'
#' @examples
#' vecc("Variable", 1)   # Returns "Variable1"
#' vecc("Q", 10)         # Returns "Q10"
vecc <- function(name, num) {
  # `paste0` concatenates its arguments without any separator.
  paste0(name, num)
}
